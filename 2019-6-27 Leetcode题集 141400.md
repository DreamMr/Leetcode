# Leetcode题集

## 950 按递增顺序显示卡牌

题意：

牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。

最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。

现在，重复执行以下步骤，直到显示所有卡牌为止：

    从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。
    如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。
    如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。

返回能以递增顺序显示卡牌的牌组顺序。

答案中的第一张牌被认为处于牌堆顶部。

 

示例：

输入：[17,13,11,2,3,5,7]
输出：[2,13,3,11,5,17,7]
解释：
我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。
重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。
我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。
我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。
我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。
我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。
我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。
我们展示 13，然后将 17 移到底部。牌组现在是 [17]。
我们显示 17。
由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。

 

提示：

    1 <= A.length <= 1000
    1 <= A[i] <= 10^6
    对于所有的 i != j，A[i] != A[j]

AC code：



```java
class Solution {
    public int[] deckRevealedIncreasing(int[] deck) {
        int []sortArray=new int[deck.length];
        for(int i=0;i<deck.length;i++)sortArray[i]=deck[i];
        Arrays.sort(sortArray);
        Queue<Integer> queue=new LinkedList<Integer>();
        int []pos=new int[deck.length];
        int tmp=-1;
        boolean flag=true;
        int point=0;
        for(int i=0;i<deck.length;i++)
        {
            
            if(flag){pos[i]=sortArray[point];flag=false;point++;}
            else
            {
                pos[i]=tmp;
                tmp--;
                flag=true;
            }
            queue.add(pos[i]);
        }
        int pointer=0;
        HashMap<Integer,Integer> mp=new HashMap<Integer,Integer>();
        
        while(!queue.isEmpty())
        {
            int t1=queue.poll();
            if(t1<0)mp.put(t1,sortArray[pointer]);
            //System.out.println(t1);
            if(!queue.isEmpty()){
            int t2=queue.poll();
            //System.out.println(t2);
            queue.add(t2);
            }
            pointer++;
        }
        for(int i=0;i<deck.length;i++)
            if(pos[i]<0)pos[i]=mp.get(pos[i]);
        return pos;
    }
}
```
###解题思路：



#674最长连续递增序列
##题目描述：
给定一个未经排序的整数数组，找到最长且连续的的递增序列。

示例 1:

输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 

示例 2:

输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。

ACcode：
```
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int ans=0;
        int []dp=new int[nums.length];
        for(int i=0;i<dp.length;i++)dp[i]=1;
        if(nums.length==0)return 0;
        ans=dp[0];
        for(int i=1;i<nums.length;i++)
        {
            if(nums[i-1]<nums[i])dp[i]=dp[i-1]+1;
            ans=Math.max(ans,dp[i]);
        }
        return ans;
    }
}
```

解题思路：这道题是一道动态规划的基础题，没什么好说的。
在这里我踩了两个坑。
1. 给定的数组长度可能为0，所以特判一下，如果数组长度为0则直接返回0.
2. dp数组的初始值为1，不能为0，因为单单一个的长度就为1。

#Leetcode136
##题目描述：
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1

示例 2:

输入: [4,1,2,1,2]
输出: 4

ACcode：
```
class Solution {
    public int singleNumber(int[] nums) {
        int ans=nums[0];
        for(int i=1;i<nums.length;i++)ans=ans^nums[i];
        return ans;
    }
}
```

解题思路：
这道题主要用到异或（XOR）的思想。
XOR运算性质：
1. 交换律
2. 结合律
3. x^0=x;x^x=0
4. 自反性：a^b^b=a^0=a

作用：
1. 在进行整数进行交换时不需要多定义一个变量。可以使用如下方式
初始：A(a) B（b）
A=A^B(a^b)
B=A^B(a^b^b)=a
A=A^B(a^b^a)=b

这道题就是运用到x^0=x这条性质，因为所有的元素要么只出现偶数次，要么只出现一次，所以偶数次的使用异或都可以变为0，而奇数次就还是其本身。

##231 2的幂
###题目描述：
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例 1:

输入: 1
输出: true
解释: 20 = 1

示例 2:

输入: 16
输出: true
解释: 24 = 16

示例 3:

输入: 218
输出: false

###ACcode：
```
class Solution {
    public boolean isPowerOfTwo(int n) {
        int i=1;
        int num=1;
        while(i<=n && num<33)
        {
            if(i==n)return true;
            i=i<<1;
            num++;
        }
        return false;
    }
}
//只需遍历32次就可以确定结果，还有O（1）的解法
```
###心得：
O(1)解法：
n&(n-1)==0

100
&

011

000

## 160相交链表

题目描述：

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：

在节点 c1 开始相交。

 

示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

 

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

 

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

###ACcode
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null && headB==null)return null;
        ListNode curA=headA;
        ListNode curB=headB;
        while(curA!=curB)
        {
            curA=curA==null?headB:curA.next;
            curB=curB==null?headA:curB.next;
        }
        return curA;
    }
}
```
###心得体会
由于题目说明不能改变链表的结构，所以不能更改前后顺序，并且需要O（n）的时间复杂度。所以对于长度不一的链表，我们可以将长的一条走完后接着走短的，短的走完后接着走长的，这样他们之间的长度差就会消掉，第二轮的时候就是一样的长度。

##141环形链表
###题目描述
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

 

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

###ACcode:
```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow=head;
        ListNode quick=head;
        if(head==null)return false;
        do
        {
            if(quick!=null && quick.next!=null)quick=quick.next.next;
            else
                return false;
            slow=slow.next;
        }while(slow!=quick);
        return true;
    }
}
```
###公式推导：
如果能够证明
$$
(2t)\%n=t\%n
$$
有解，说明一个快一个慢，如果有环，他们一定会在t回合重逢。

$$
if\ t\ <\ n\ <=\ 2t,\\
2t-nz=t\ \ =>\ \ t=nz(z=1)\\
becaues\ t<\ n\\
so\\
无解
$$
意味着一个快一个慢，在一个回合内不会重逢。
如果t=n，则会在末尾重逢。
$$
if\ \ n<\ t<\ 2t\\
2t-nz_1=t-nz_2\\
t=n(z_1-z_2)(z_1>z_2)\\
有解
$$
意味着在多个回合内一定会有重逢。

##236LCA
###题目描述
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

 

示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

###ACcode
```
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
       return lca(root,p,q);
    }
    TreeNode lca(TreeNode root,TreeNode p,TreeNode q)
    {
        if(root==null)return null;
        if(root==p || root==q)
            return root;
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left!=null && right!=null)
        {
            return root;
        }
        else if(left!=null)return left;
        else if(right!=null)return right;
        else return null;
    }
}
```
###心得体会
寻找最近的同时能够达到的根节点。

##33.搜索旋转排序数组
###题目描述
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

示例 2:

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1


###code
```
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(left<=right)
        {
            int mid=(left+right)>>1;
            if(nums[mid]==target)return mid;
            if(left==right)return -1;
            if(nums[left]<nums[mid])//左边有序
            {
                if(target<=nums[mid-1] && target>=nums[left])right=mid-1;
                else left=mid;
            }
            else//右边可能有序
            {
                if(target<=nums[right] && target>=nums[mid+1])left=mid+1;
                else right=mid;
            }
        }
        return -1;
    }
}
```
###解题思路：
在一个拐点的一侧肯定有一侧是有序的，这时候判断左边还是右边有序，然后确定target是否在有序的一侧。这道题是一道经典题，很重要，做了好几遍还不会。

##54螺旋矩阵
###题目描述
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例 1:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]

示例 2:

输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]

###ACcode
```
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list=new ArrayList<Integer>();
        int state=0;
        int num=0;
        if(matrix.length==0)return list;
        int sum=matrix.length*matrix[0].length;
        int m=matrix.length;
        int n=matrix[0].length;
        //list.add(matrix[0][0]);
        //num++;
        while(list.size()<sum)
        {
            if(state==0)
            {
                for(int i=matrix[0].length-n;i<n;i++)
                    list.add(matrix[matrix.length-m][i]);
                //num+=n-matrix[0].length+n;
            }
            else if(state==1)
            {
                for(int i=matrix.length-m+1;i<m;i++)
                {
                    if(n-1==-1)return list;
                    list.add(matrix[i][n-1]);
                }
                //num+=m-matrix.length+m-1;
            }
            else if(state==2)
            {
                for(int i=n-1-1;i>=matrix[0].length-n;i--)
                    list.add(matrix[m-1][i]);
                //num+=n-1-1-matrix[0].length+n+1;
            }
            else if(state==3)
            {
                for(int i=m-1-1;i>=matrix.length-m+1;i--)
                    list.add(matrix[i][matrix[0].length-n]);
                m--;
                //num+=matrix.length-m+1-m+2+1;
                n--;
            }
            state=(state+1)%4;
        }
        return list;
    }
}
```
###解题思路
一道模拟题，但是其中细节问题较为复杂。

## 142环形链表

- 题目描述

  给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

  为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

  **说明：**不允许修改给定的链表。

   

  **示例 1：**

  ```
  输入：head = [3,2,0,-4], pos = 1
  输出：tail connects to node index 1
  解释：链表中有一个环，其尾部连接到第二个节点。
  ```

  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

  **示例 2：**

  ```
  输入：head = [1,2], pos = 0
  输出：tail connects to node index 0
  解释：链表中有一个环，其尾部连接到第一个节点。
  ```

- ACcode

  ```java
   public ListNode detectCycle(ListNode head) {
          ListNode quick=head;
          ListNode slow=head;
          while(slow!=null && quick!=null)
          {
              slow=slow.next;
              if(quick.next!=null)
              quick=quick.next.next;
              else return null;
              if(slow==quick)break;
          }
          if(slow==null || quick==null)return null;
          ListNode p=head;
          while(p!=slow)
          {
              p=p.next;
              slow=slow.next;
          }
          return p;
      }
  ```

  

- 解题思路

  这道题要分两步走。

  1. 首先要判断是否有环。判断是否有环用前面的快慢指针方法即可。

  2. 确定环的第一个入口。

     假设从起始点到环的入口点的距离为a，环的入口到快慢指针相遇的位置距离为b，那么有下面的等式：
     $$
     a+b=2(a+b) \ \ \ \ \ \ \ \ 快慢指针到相同位置
     $$
     所以慢指针下次走到该点的距离是a+b，由于b是固定的，所以我们在起点从新设一个慢指针，当满指针与新慢指针重合时就是入口。

     ![1549024594658](G:\资源\%5CUsers%5C76104%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1549024594658.png)

     



## 146LRU缓存机制

- 题目描述

  运用你所掌握的数据结构，设计和实现一个  [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU)。它应该支持以下操作： 获取数据 `get` 和 写入数据 `put` 。

  获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
   写入数据 `put(key, value)` - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

  **进阶:**

  你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

  **示例:**

  ```
  LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
  
  cache.put(1, 1);
  cache.put(2, 2);
  cache.get(1);       // 返回  1
  cache.put(3, 3);    // 该操作会使得密钥 2 作废
  cache.get(2);       // 返回 -1 (未找到)
  cache.put(4, 4);    // 该操作会使得密钥 1 作废
  cache.get(1);       // 返回 -1 (未找到)
  cache.get(3);       // 返回  3
  cache.get(4);       // 返回  4
  ```

- ACcode

  ```java
  class LRUCache {
      private LRU cache;
      public LRUCache(int capacity) {
          cache=new LRU(capacity);
      }
      
      public int get(int key) {
         if(cache.containsKey(key))return cache.get(key);
          else return -1;
      }
      
      public void put(int key, int value) {
         cache.put(key,value);
      }
  }
  class LRU extends LinkedHashMap<Integer,Integer>{
      int capacity;
      public LRU(int capacity)
      {
          super(capacity,0.75f,true);
          this.capacity=capacity;
      }
      
       @Override
          protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
              return this.size() > capacity;
          }
  }
  
  /**
   * Your LRUCache object will be instantiated and called as such:
   * LRUCache obj = new LRUCache(capacity);
   * int param_1 = obj.get(key);
   * obj.put(key,value);
   */
  ```

  

- 解题思路

  这道题是利用了java中的LinkedHashMap的数据结构，其在HashMap的基础上新增加一个链表来记录插入的顺序或者是访问的顺序。如果是最近刚刚访问过的将会插入至链表的末尾。在removeEldestEntry函数中，如果返回true则删除最老的元素。一般实现LRU算法，都需要在构造函数中指定是按照插入的顺序（false）进行排列还是按照访问的顺序（true）来进行排序。

## 15 三数之和

题目描述

- 给定一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？找出所有满足条件且不重复的三元组。

  **注意：**答案中不可以包含重复的三元组。

  ```
  例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
  
  满足要求的三元组集合为：
  [
    [-1, 0, 1],
    [-1, -1, 2]
  ]
  ```

- ACcode

  ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
          Arrays.sort(nums);
          List<List<Integer>> ans=new ArrayList<>();
          for(int i=0;i<nums.length;i++)
          {
              int tmp=-nums[i];
              if(i>0 && nums[i]==nums[i-1])continue;
              int j=i+1;
              int k=nums.length-1;
              while(j<k)
              {
                  int mid=(j+k)>>1;
                  if(nums[j]+nums[k]<tmp)j++;
                  else if(nums[j]+nums[k]>tmp)k--;
                  else if(nums[j]+nums[k]==tmp)
                  {
                      List<Integer>list=new ArrayList<Integer>();
                      list.add(nums[i]);list.add(nums[j]);list.add(nums[k]);
                      ans.add(list);
                      do
                      {
                          j++;
                      }
                      while(j<k && nums[j-1]==nums[j]);
                      do{
                          k--;
                      }while(j<k && nums[k+1]==nums[k]);
                  }
              }
          }
          return ans;
      }
  }
  ```

- 解题思路

  1.将数组排序
  2.定义三个指针，i，j，k。遍历i，那么这个问题就可以转化为在i之后的数组中寻找nums[j]+nums[k]=-nums[i]这个问题，也就将三数之和问题转变为二数之和---（可以使用双指针）

  **注意去重！** 

  在判断某一个数组是正确答案后需要判断后面一个值与当前值是否相同，如果相同会造成答案的重复。

  

  ## 240搜索二维矩阵 II

  - 题目描述

    编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

    - 每行的元素从左到右升序排列。
    - 每列的元素从上到下升序排列。

    **示例:**

    现有矩阵 matrix 如下：

    ```
    [
      [1,   4,  7, 11, 15],
      [2,   5,  8, 12, 19],
      [3,   6,  9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30]
    ]
    ```

    给定 target = `5`，返回 `true`。

    给定 target = `20`，返回 `false`。

  - ACcode

    ```java
    class Solution {
        public boolean searchMatrix(int[][] matrix, int target) {
            if(matrix.length==0)return false;
            int i=0;int j=matrix[0].length-1;
            while(i<matrix.length && j>=0)
            {
                if(target<matrix[i][j])
                {
                    j--;
                    continue;
                }
                else if(target>matrix[i][j])
                {
                    i++;
                    continue;
                }
                else
                    return true;
            }
            return false;
        }
    }
    ```

    

  - 解题思路

    利用这题矩阵数字排序的关系，先从右上开始判断，如果比当前数字小，则肯定在这一列的左侧，所以删除这一列。如果大于等于该值，在看是否大于这个值，如果大于，则删除这一行。

  ## 877 石子游戏

  - 题意

    亚历克斯和李用几堆石子在做游戏。偶数堆石子**排成一行**，每堆都有正整数颗石子 `piles[i]` 。

    游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

    亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

    假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 `true` ，当李赢得比赛时返回 `false` 。

     

    **示例：**

    ```
    输入：[5,3,4,5]
    输出：true
    解释：
    亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
    假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
    如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
    如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
    这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。
    ```

     

    **提示：**

    1. `2 <= piles.length <= 500`
    2. `piles.length` 是偶数。
    3. `1 <= piles[i] <= 500`
    4. `sum(piles)` 是奇数。

  - ACcode

    ```java
    class Solution {
        int [][]dp;
        public boolean stoneGame(int[] piles) {
            int N=piles.length;
            dp=new int[N+1][N+1];
            for(int i=0;i<N;i++)
                for(int j=0;j<N;j++)
                        dp[i][j]=-1;
            return solve(0,N-1,true,piles)>0;
        }
        int solve(int i,int j,boolean flag,int []piles)
        {
            if(dp[i][j]!=-1)return dp[i][j];
            if(i==j)
                if(flag)
                    return dp[i][i];
                else
                    return -dp[i][i];
            if(flag)
                dp[i][j]=Math.max(piles[i]+solve(i+1,j,!flag,piles),piles[j]+solve(i,j-1,!flag,piles));
            else
                dp[i][j]=Math.min(-piles[i]+solve(i+1,j,!flag,piles),-piles[j]+solve(i,j-1,!flag,piles));
            return dp[i][j];
        }
    }
    ```

    

  - 解题思路

    1. 动态规划方法

       递推公式：
       $$
       if \ Ya \\
       \ \ dp(i,j)=max(piles[i]+dp(i+1,j),piles[j]+dp(i,j-1))\\
       else\\
       dp(i,j)=min(-piles[i]+dp(i+1,j),-piles[j]+dp(i,j-1))
       $$
       最后判断dp(1,N)是否大于0，大于0亚胜。因为dp存的是两人之间的差值。

    2. 数学方法

       容易知道当石子堆数为2时亚历克斯赢。

       如果亚历克斯最初获得第一堆，她总是可以拿第三堆。 如果她最初取到第四堆，她总是可以取第二堆。`第一+第三，第二+第四` 中的至少一组是更大的，所以她总能获胜。

       我们可以将这个想法扩展到 `N` 堆的情况下。设第一、第三、第五、第七桩是白色的，第二、第四、第六、第八桩是黑色的。 亚历克斯总是可以拿到所有白色桩或所有黑色桩，其中一种颜色具有的石头数量必定大于另一种颜色的。

       因此，亚历克斯总能赢得比赛。

    ## 96 不同的二叉搜索树

    - 题意

      给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

      **示例:**

      ```
      输入: 3
      输出: 5
      解释:
      给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
      
         1         3     3      2      1
          \       /     /      / \      \
           3     2     1      1   3      2
          /     /       \                 \
         2     1         2                 3
      ```

    - ACcode

      ```java
      class Solution {
          public int numTrees(int n) {
              int []dp=new int [n+1];
              dp[0]=1;
              dp[1]=1;
              if(n<2)return dp[n];
              dp[2]=2;
              for(int i=3;i<=n;i++)
              {
                  dp[i]=0;
                  for(int j=1;j<=i;j++)
                  {
                      dp[i]+=dp[j-1]*dp[i-j];
                  }
              }
              return dp[n];
          }
      }
      ```

      

    - 解题思路

      一棵二叉搜索树的个数=左子树的个数*右子树的个数。

      以1为根节点的时候：左子树个数为0，右子树个数为n-1，但是0不能乘0，设为dp[0]=1，

      以n为根节点的时候：左子树的个数为dp[n-1] (有n-1个数比n小，都在左侧）

      右子树的个数为dp[i-n]，当前总节点个数-n个节点。所以可以递归的计算。

    ## 牛客网字母交换

    - 题意

      链接：

      https://www.nowcoder.com/questionTerminal/95c4e22f7e9d4bda85c5b52cacc9bfb5?orderByHotValue=1&page=1&onlyReference=false

      来源：牛客网

      【编码题】字符串S由小写字母构成，长度为n。定义一种操作，每次都可以挑选字符串中任意的两个相邻字母进行交换。询问在至多交换m次之后，字符串中最多有多少个连续的位置上的字母相同？  

        


      ##### **输入描述:**
    
      ```
      第一行为一个字符串S与一个非负整数m。(1 <= |S| <= 1000, 1 <= m <= 1000000)
      ```
    
      ##### **输出描述:**
    
      ```
      一个非负整数，表示操作之后，连续最长的相同字母数量。
      ```
    
       示例1 
    
      ## 输入
    
      ```
      abcbaa 2
      ```
    
      ## 输出
    
      ```
      2
      ```
    
      ## 说明
    
      ```
      使2个字母a连续出现，至少需要3次操作。即把第1个位置上的a移动到第4个位置。
      所以在至多操作2次的情况下，最多只能使2个b或2个a连续出现。
      ```
    
    - ACcode
    
      ```c++
      #include<iostream>
      #include<algorithm>
      #include<string.h>
      
      using namespace std;


​      
​      int solve(int i,int j,int m[])
​      {
​          if(i==j)return 0;
​          else if(i+1==j)return m[j]-m[i]-1;
​          else
​          {
​              return solve(i+1,j-1,m)+m[j]-m[i]-(j-i);//最后的减法是中间有相同的字母。
​          }
​      }
​      int main()
​      {
​          string str;
​          int num=0;
​          cin>>str>>num;
​          int len=str.length();
​          char a[len][26];
​          int m[len];
​          memset(a,0,sizeof(a));
​          memset(m,0,sizeof(m));
​          for(int i=0;i<len;i++)
​          {
​              a[i][str[i]-'a']=1;
​          }
​          int ans=0;
​          for(int i=0;i<26;i++)
​          {
​              int k=0;
​              for(int j=0;j<len;j++)
​              {
​                  if(a[j][i]==1)
​                  {
​                      m[k++]=j;
​                  }
​              }
​              if(k==1){ans=max(ans,1);continue;}
​              for(int t=0;t<k;t++)
​              {
​                  for(int tt=t+1;tt<k;tt++)
​                  {
​                      if(solve(t,tt,m)<=num)
​                      {
​                          ans=max(ans,tt-t+1);
​                      }
​                  }
​              }
​          }
​          cout<<ans<<endl;
​          return 0;
​      }
​      ```


​      

    - 解题思路
    
      先统计每一种字符在字符串中的位置，然后针对每种字符利用动态规划计算最小需要移动几步
    
    - 注意事项
    
      这道题不能一下子开太大的数组，根据给的字符串长度来开，否则会提示段错误。
    
    ## 牛客网-小米笔试动态规划（股票）
    
    - 题目描述
    
      风口之下，猪都能飞。当今中国股市牛市，真可谓“错过等七年”。 给你一个回顾历史的机会，已知一支股票连续n天的价格走势，以长度为n的整数数组表示，数组中第i个元素（prices[i]）代表该股票第i天的股价。 假设你一开始没有股票，但有至多两次买入1股而后卖出1股的机会，并且买入前一定要先保证手上没有股票。若两次交易机会都放弃，收益为0。 设计算法，计算你能获得的最大收益。 输入数值范围：2<=n<=100,0<=prices[i]<=100 
    
      ##### **输入例子1:**
    
      ```
      3,8,5,1,7,8
      ```
    
      ##### **输出例子1:**
    
      ```
      12
      ```
    
    - ACcode
    
      ```java
      public class Solution {
          /**
           * 计算你能获得的最大收益
           * 
           * @param prices Prices[i]即第i天的股价
           * @return 整型
           */
          public int calculateMax(int[] prices) {
               int min=prices[0];
              int []left=new int [prices.length];
              int []right=new int [prices.length];
              int max=prices[prices.length-1];
              left[0]=0;
              for(int i=1;i<prices.length;i++)
              {
                  if(min>prices[i])min=prices[i];
                  left[i]=prices[i]-min>left[i-1]?prices[i]-min:left[i-1];
              }
              right[prices.length-1]=0;
              for(int i=prices.length-2;i>=0;i--)
              {
                  if(max<prices[i])max=prices[i];
                  right[i]=max-prices[i]>right[i+1]?max-prices[i]:right[i+1];
              }
              max=0;
              for(int i=0;i<prices.length;i++)
              {
                  if(max<left[i]+right[i])max=left[i]+right[i];
              }
              return max;
          }
      }
      ```


​      

    - 解法
    
      这道题是一道动态规划的题，他只能购买两次股票。所以定义两个数组。
    
      首先是left数组，其含义是到当前时间节点为止，能够取得的最大收益。
    
      而right数组，其含义是从当前时间节点开始，到后面所能够的到的最大收益。
    
      那么最开始的疑惑是这样为什么就可以避免重复。
    
      因为根据数组的含义，在刚好获得最大收益的left数组不可能在right数组取得最大收益。因为在最高点处买入不可能在后面有高收入。
    
    ## 121买卖股票的最佳时机
    
    - 题目描述
    
      给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
    
      如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。
    
      注意你不能在买入股票前卖出股票。
    
      **示例 1:**
    
      ```
      输入: [7,1,5,3,6,4]
      输出: 5
      解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
           注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
      ```
    
      **示例 2:**
    
      ```
      输入: [7,6,4,3,1]
      输出: 0
      解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
      ```
    
    - ACcode
    
      ```java
      class Solution {
          public int maxProfit(int[] prices) {
              if(prices.length==0)return 0;
              int min=prices[0];
              int []left=new int [prices.length];
              left[0]=0;
              for(int i=1;i<prices.length;i++)
              {
                  if(prices[i]<min)min=prices[i];
                  left[i]=prices[i]-min>left[i-1]?prices[i]-min:left[i-1];
              }
              int ans=left[0];
              for(int i=1;i<left.length;i++)
              {
                  ans=Math.max(ans,left[i]);
              }
              return ans;
          }
      }
      ```


​      

    - 思路
    
      直接走一遍，用left数组求出到当前为止收益最大值。
    
    ## 122买卖股票的最佳时机ii
    
    - 题目描述
    
      给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
    
      设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
    
      **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    
      **示例 1:**
    
      ```
      输入: [7,1,5,3,6,4]
      输出: 7
      解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
           随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
      ```
    
      **示例 2:**
    
      ```
      输入: [1,2,3,4,5]
      输出: 4
      解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
           注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
           因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
      ```
    
      **示例 3:**
    
      ```
      输入: [7,6,4,3,1]
      输出: 0
      解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
      ```
    
    - ACcode
    
      ```java
      class Solution {
          public int maxProfit(int[] prices) {
              int ans=0;
              boolean state=false;
              for(int i=0;i<prices.length-1;i++)
              {
                  if(prices[i]<prices[i+1] && !state)
                  {
                      ans-=prices[i];
                      state=true;
                  }
                  else if(prices[i]>prices[i+1] && state)
                  {
                      ans+=prices[i];
                      state=false;
                  }
              }
              if(state)
              {
                  ans+=prices[prices.length-1];
              }
              return ans;
          }
      }
      ```


​      

    - 解题思路
    
      这道题是购买股票可以购买任意多的股票，那么我们只要判断是转折点就可以购买。为什么因为只要有转折点我们都可以赚差价，无论后面是不是会有更高的价格。
    
    ## 188买卖股票的最佳时机 IV
    
    - 题目描述
    
      给定一个数组，它的第 *i* 个元素是一支给定的股票在第 *i* 天的价格。
    
      设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。
    
      **注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    
      **示例 1:**
    
      ```
      输入: [2,4,1], k = 2
      输出: 2
      解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
      ```
    
      **示例 2:**
    
      ```
      输入: [3,2,6,5,0,3], k = 2
      输出: 7
      解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
           随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
      ```
    
    - ACcode
    
      ```java
      class Solution {
          public int maxProfit(int k, int[] prices) {
              if(k==0 ||prices.length==0)return 0;
              if(k>prices.length/2)
              {
                  return gc(prices);
              }
              int []sell=new int[k];
              int []buy=new int[k];
              for(int i=0;i<k;i++)
              {
                  buy[i]=-prices[0];
                  sell[i]=0;
              }
              for(int i=1;i<prices.length;i++)
              {
                  sell[0]=Math.max(sell[0],buy[0]+prices[i]);
                  buy[0]=Math.max(buy[0],-prices[i]);
                  for(int j=k-1;j>0;j--)
                  {
                      sell[j]=Math.max(sell[j],buy[j]+prices[i]);
                      buy[j]=Math.max(buy[j],sell[j-1]-prices[i]);
                  }
              }
              return sell[k-1];
          }
          int gc(int []prices)
          {
              int ans=0;
              boolean state = false;
              for(int i=0;i<prices.length-1;i++)
              {
                  if(prices[i]<prices[i+1] && !state)
                  {
                      ans-=prices[i];
                      state=true;
                  }
                  else if(prices[i]>prices[i+1] && state)
                  {
                      state=false;
                      ans+=prices[i];
                  }
              }
              if(state)
              {
                  ans+=prices[prices.length-1];
              }
              return ans;
          }
      }
      ```


​      

    - 解题思路
    
      这道题如果k大于给定天数的一半，那么就退化成可以可以购买无限次。为什么？因为每次升降都需要两天。所以如果超过给定天数的一半，则为无限次。
    
      其次就是动态规划方程。
    
      设置两个数组sell[] 和buy[]。
    
      sell[i]的含义是在第i次卖出去取得的最大利润。
    
      buy[i]的含义是在第i次买进取得的最大利润。
    
      首先是动态规划方程：
    
      sell[j]=max(第i-1天之前的sell[j],第i-1天之前买入的最大利润buy[j]+prices[i])
    
      buy[j]=max(第i-1天之前的buy[j]，第i-1天之前的卖的第k-1次的最大利润sell[j-1]-prices[i])
    
      初始化：
    
      sell[0]=max(sell[0],buy[0]+prices[i])//之前卖1次的最大利润与买入第一次后在卖的利润
    
      buy[0]=max(buy[0],-prices[i])//之前记录的买入的最大利润与当天的价格取最小值，其实就是比较每天的最小值。


​    

​    

  

  ## leetcodde42 接雨水

- 题目描述

  给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

  上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

  **示例:**

  ```
  输入: [0,1,0,2,1,0,1,3,2,1,2,1]
  输出: 6
  ```

- ACcode

  ```java
  class Solution {
      public int trap(int[] height) {
          if(height.length==0)return 0;
          int []left=new int [height.length];
          int []right=new int [height.length];
          int mmax=height[0];
          left[0]=height[0];
          for(int i=1;i<height.length;i++)
          {
              if(height[i]>mmax)
                  mmax=height[i];
              left[i]=Math.max(left[i-1],mmax);
          }
          mmax=height[height.length-1];
          right[height.length-1]=height[height.length-1];
          for(int i=height.length-2;i>=0;i--)
          {
              if(height[i]>mmax)
                  mmax=height[i];
              right[i]=Math.max(right[i+1],mmax);
          }
          int ans=0;
          for(int i=0;i<height.length;i++)
          {
              ans+=Math.min(left[i],right[i])-height[i];
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  这道题和前面的买股票的思路类似，也是通过两个数组分别向左和向右看来进行求解。

  首先为什么要这么做？

  这道题需要求解能接多少水，也就是求之间的凹槽。构成凹槽肯定就是两边都比中间高。

  通过left数组来存储从当前点一直往左的最大值，而right数组来存储从当前点开始一直往右的最大值，然后在计算某一个位置的节水量的时候求当前点两边的最大值（left数组和right数组）中的最小值来减去当前点的高度就是凹槽所能接的水量。left

  数组和right数组分别记录的就是某个点两侧的最大值。

## 最大乘积

- 题目描述

  ## 题目描述

  给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1)

  ## 输入描述:

  ```
  无序整数数组A[n]
  ```

  ## 输出描述:

  ```
  满足条件的最大乘积
  ```

   示例1 

  ## 输入

  复制

  ```
  3 4 1 2
  ```

  ## 输出

  复制

  ```
  24
  ```

- ACcode

  ```java
  import java.util.*;
  import java.io.*;
  import java.math.*;
  
  public class Main{
      long []tmp=null;
      long []tmp2=null;
      int getMin()
      {
          int cur=0;
          long mmin=Math.min(tmp2[0],Math.min(tmp2[1],tmp2[2]));
          for(int i=0;i<tmp2.length;i++)
          {
              if(mmin==tmp2[i])
              {
                  cur=i;
                  break;
              }
          }
          return cur;
      }
      int getMax()
      {
          int cur=0;
          long mmin=Math.max(tmp[0],tmp[1]);
          if(mmin==tmp[0])return 0;
          else return 1;
      }
      void solve()
      {
          tmp=new long[3];
          tmp2=new long[3];
          Scanner scan=new Scanner(System.in);
          ArrayList<Long> arrayList=new ArrayList<>();
          int n=scan.nextInt();
          for(int i=0;i<n;i++)
          {
              arrayList.add(scan.nextLong());
          }
          long ans=1;
          int num=0;
          int z_num=0;
          int f_num=0;
          
         
              num=0;
              long mmax=arrayList.get(0);
              for(int i=0;i<arrayList.size();i++)
              {
                  long ttmp=arrayList.get(i);
                  if(num<2)
                  {
                      tmp[num]=ttmp;
                      num++;
                  }
                  else
                  {
                      int mmmax=getMax();
                      if(tmp[mmmax]>ttmp)tmp[mmmax]=ttmp;
                  }
                  mmax=Math.max(mmax,ttmp);
              }
              tmp[2]=mmax;
          
          
              num=0;
              for(int i=0;i<arrayList.size();i++)
              {
                  long ttmp=arrayList.get(i);
                  if(num<3)
                  {
                      tmp2[num]=ttmp;
                      num++;
                  }
                  else
                  {
                      int mmin=getMin();
                      if(tmp2[mmin]<ttmp)tmp2[mmin]=ttmp;
                  }
              }
          
          ans=Math.max(tmp[0]*tmp[1]*tmp[2],tmp2[0]*tmp2[1]*tmp2[2]);
          System.out.println(ans);
      }
      public static void main(String []args)
      {
          Main mm=new Main();
          mm.solve();
      }
  }
  ```

  

- 解题思路

  这道题需要进行分类。

  分成以下三类：

  1. 全为正数，则最大值为最大的三个数。
  2. 全为负数，则最大值为最大的三个数。
  3. 如果有正有负，则要么是最小的两个数乘最大的正数，或者是三个最大的正数。

## 剑指Offer二叉搜索树的后序遍历序列

- 题目描述

  输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

- ACcode

  ```java
  public class Solution {
      public boolean VerifySquenceOfBST(int [] sequence) {
          if(sequence.length==0)return false;
          return solve(sequence,0,sequence.length-1);
      }
      boolean solve(int []seq,int left,int right)
      {
          if(right-left<=1)return true;
          int lnum=0;
          for(int i=left;i<right;i++)
          {
              if(seq[i]<seq[right])
                  lnum++;
              else
              {
                  break;
              }
          }
          int lleft=left;
          int lright=left+lnum-1;
          int rleft=lright+1;
          int rright=right-1;
          int rnum=rright-rleft+1;
          for(int i=rleft;i<=rright;i++)
              if(seq[i]<seq[right])return false;
          boolean lflag=true;
          boolean rflag=true;
          if(lnum!=0)lflag=solve(seq,lleft,lright);
          if(rnum!=0)rflag=solve(seq,rleft,rright);
          return lflag&&rflag;
      }
  }
  ```

  

- 解题思路

  二叉搜索树的中序遍历是从小到大排序的序列。

  而后序遍历的最后一个节点是根节点，所以可以将序列分为三个部分，前面第一部分是左子树，中间部分是右子树，最后一个节点是根节点。所以前面一部分的每个节点都会比根节点的值小，而中间部分的节点每个节点都会比根节点大。然后这样递归下去直到只剩下2个长度大小的节点时可以直接返回true，因为两个节点无论是左子树还是右子树都是满足条件的。

## 剑指Offer 复杂链表的复制

- 题意

  输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

- ACcode

  ```java
  /*
  public class RandomListNode {
      int label;
      RandomListNode next = null;
      RandomListNode random = null;
  
      RandomListNode(int label) {
          this.label = label;
      }
  }
  */
  public class Solution {
      public RandomListNode Clone(RandomListNode pHead)
      {
          if(pHead==null)return null;
          RandomListNode cur=pHead;
          RandomListNode mycur=null;
          while(cur!=null)
          {
              mycur=cur.next;
              cur.next=new RandomListNode(cur.label);
              cur=cur.next;
              cur.next=mycur;
              cur=mycur;
          }
          cur=pHead;
          
          while(cur!=null)
          {
              RandomListNode tmp=cur.random;
              if(tmp!=null)
                  cur.next.random=new RandomListNode(tmp.next.label);
              cur=cur.next.next;
          }
          cur=pHead;
          mycur=cur.next;
          RandomListNode ans=mycur;
          while(cur!=null)
          {
              cur.next=mycur.next;
              if(mycur.next==null)break;
              mycur.next=mycur.next.next;
              cur=cur.next;
              mycur=mycur.next;
          }
          return ans;
          
      }
  }
  ```

  

- 解题思路

  这道题有三种解法。

  1. 时间复杂度为O(n^2)。首先根据链表的next进行构造新的节点，然后再找随机节点，随机节点是从头开始遍历查找，所以时间复杂度较高。
  2. 时间复杂度为O(n),空间复杂度为O(n)，还是跟前面一样利用next先构造链表，然后利用哈希来存储<N,N'>,这样在构造随机节点的时候可以根据哈希来进行查找时间复杂度为O（1）.
  3. 时间复杂度为O（n），空间复杂度为O（1）.还是跟前面一样根据next构建节点，但是这时构建节点是直接跟在该节点的后面，例如N->N'.这样在后面查找随机节点的时候就可以利用原链表查找随机节点的下一个节点就是新复制链表的对应节点的随机节点。

## 整数中1出现的次数

- 题目描述

  求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1
  到 n 中1出现的次数）。

- ACcode

  ```java
  public class Solution {
      public int NumberOf1Between1AndN_Solution(int n) {
          Integer N=n;
          int ans=solve(N.toString());
          return ans;
      }
      int solve(String str)
      {
          if(str.length()==1 && str.charAt(0)>'0')return 1;
          if(str.length()==1 && str.charAt(0)=='0')return 0;
          int ans=0;
          if(str.charAt(0)>'1'){ans+=power(10,str.length()-1);}
          else if(str.charAt(0)=='1'){ans+=Integer.parseInt(str)-power(10,str.length()-1)+1;}
          Integer tmp=Integer.parseInt(String.valueOf(str.charAt(0)));
          ans+=(str.length()-1)*tmp*power(10,str.length()-2);
          ans+=solve(str.substring(1));
          return ans;
      }
      int power(int base,int k)
      {
          int ans=1;
          while(k>0)
          {
              if((k&1)==1)ans*=base;
              base*=base;
              k>>=1;
          }
         return ans;
      }
  }
  ```

  - 解题思路

    这道题如果用暴力的话一个一个的判断每一位是否为1，时间复杂度会有O（nlogn），如果尝试着从构造开始想的话时间复杂度为O（logn）。

    例如21345，我们先拆成1~1345和1346~21345。

    首先看1346~21345这一部分，先看最高位万位，从10000~19999，一共有10000个万位为1，如果小于2，例如12345，则为12345-10000+1个万位为1。

    然后在看除万位之外的三位，他们中有1的个数为2\*10^3\*4,因为有20000个数，在4位中选择其中一位为1，其余三位为0~9。

    然后再看1~1345，这时可以用递归的方式在计算1345。

  ## 和为S的连续正数序列

  - 题目描述

    小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?

    ```
    输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
    ```

  - ACcode

    ```java
    import java.util.ArrayList;
    public class Solution {
        public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
           int start=1;
            int end=2;
            int s=start+end;
            ArrayList<ArrayList<Integer> > ans= new ArrayList<ArrayList<Integer> >();
            while(start<=(sum>>1))
            {
                if(s==sum)
                {
                    ArrayList<Integer> tmp=new ArrayList<>();
                    for(int i=start;i<=end;i++)
                    {
                        tmp.add(i);
                    }
                    ans.add(tmp);
                    end++;
                    s+=end;
                }
                else if(s<sum)
                {
                    end++;
                    s+=end;
                }
                else if(s>sum)
                {
                    s-=start;
                    start++;
                }
            }
            return ans;
        }
    }
    ```

    

  - 解题思路

    题目中求的是一段连续的序列，那么使用两个指针start和end代表这个区间的头和尾。开始时只有1和2，然后再用一个s来记录当前区间的和为多少。如果当前区间的和小于sum，则end往后移一位。如果当前区间的和大于sum，则start往后移一位，同时s减去移之前的数。

    如果相等则添加进ans数组中。那么什么时候结束呢？我给出的答案是当start>sum/2时结束。（是否有更精确的值有待考证！）

  ## 亚瑟夫环问题解法

  - 题目描述

    每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

  - ACcode

    解法1（常规解法）

    ```java
    import java.util.*;
    public class Solution {
        public int LastRemaining_Solution(int n, int m) {
            boolean []isLive=new boolean[n];
            Arrays.fill(isLive,true);
            int cn=0;
            int cm=0;
            int num=n;
            while(num>1)
            {
                if(cm==m-1)
                {
                    cm=0;
                    isLive[cn]=false;
                    num--;
                }
                else
                    cm=(cm+1)%m;
                do
                {
                    cn=(cn+1)%n;
                }while(!isLive[cn]);
            }
            for(int i=0;i<isLive.length;i++)
                if(isLive[i])return i;
            return -1;
        }
    }
    ```

    解法2（数学解法）

    ```java
    import java.util.*;
    public class Solution {
        public int LastRemaining_Solution(int n, int m) {
            //**************数学解法
            if(n<1 || m==0)return -1;
            if(n==1)return 0;
            return (LastRemaining_Solution(n-1,m)+m)%n;
        }
    }
    ```

    

  - 解题思路

    1. 常规解法

       直接暴力判断

    2. 数学解法
       $$
       假设f(n,m)为有n个人，每次叫道m-1的人就出去最后剩下的人。\\
       现在假设第一次有人被叫出去后设k=(m-1)\%n，那么下一次从k+1开始\\
       那此时不能再用前面的f函数了，因为起点不同，再假设一个函数f'(n-1,m)。\\
       通过公式推导可知从当前位置映射到0可用映射p(x)=|(x-k-1)\%n|，那么逆映射就为\\
       p^{-1}(x)=|(x+k+1)\%n|;\\以下为公式推导：\\
       f'(n-1,m)=p^{-1}(f(n-1,m))=(f(n-1,m)+k+1)\%n=(f(n-1,m)+m)\%n\\
       所以得递推公式：
       f(n,m)=\begin{cases} 0,\ \ \ sn=1\\ [f(n-1,m)+m]\%n  \ \ \ \ \ n>1 \end{cases}
       $$
       

  


## 最大交换 Leetcode670

- 题目描述

  给定一个非负整数，你**至多**可以交换一次数字中的任意两位。返回你能得到的最大值。

  **示例 1 :**

  ```
  输入: 2736
  输出: 7236
  解释: 交换数字2和数字7。
  ```

  **示例 2 :**

  ```
  输入: 9973
  输出: 9973
  解释: 不需要交换。
  ```

  **注意:**

  1. 给定数字的范围是 [0, 108]

- ACcode

  ```java
  class Solution {
      public int maximumSwap(int num) {
          StringBuilder sb=new StringBuilder(String.valueOf(num));
          for(int i=1;i<sb.length();i++)
          {
              if(sb.charAt(i-1)<sb.charAt(i))
              {
                  char mmax=sb.charAt(i);
                  int cur=i;
                  for(int j=i;j<sb.length();j++)
                  {
                      if(mmax<=sb.charAt(j))
                      {
                          mmax=sb.charAt(j);
                          cur=j;
                      }
                  }
                  swap(sb,0,cur);
                  return Integer.parseInt(sb.toString());
              }
              else if(sb.charAt(i-1)>sb.charAt(i))
              {
                  for(int j=i+1;j<sb.length();j++)
                  {
                      if(sb.charAt(j)>sb.charAt(j-1))
                      {
                          char mmax=sb.charAt(j-1);
                          int cur=j-1;
                          for(int t=j-1;t<sb.length();t++)
                          {
                              if(mmax<=sb.charAt(t))
                              {
                                  mmax=sb.charAt(t);
                                  cur=t;
                              }
                          }
                          for(int t=0;t<=j-1;t++)
                          {
                              if(sb.charAt(t)<mmax)
                              {
                                  swap(sb,t,cur);
                                  break;
                              }
                          }
                          return Integer.parseInt(sb.toString());
                      }
                  }
                  return Integer.parseInt(sb.toString());
              }
          }
          return Integer.parseInt(sb.toString());
      }
      void swap(StringBuilder sb,int i,int j)
      {
          char ch=sb.charAt(i);
          sb.setCharAt(i,sb.charAt(j));
          sb.setCharAt(j,ch);
      }
  }
  ```

  

- 解题思路

  这道题给的大小只是到10^8，所以n^2也是可以的，毕竟是16.。。。

  还有一种O（n）的解法。

  首先分两种情况：

  1. 一开始升序：则找到最后面最大的值和第一个进行交换，因为第一个肯定不是最大，所以将最大的移到高位一定是最大的。这里注意，如果有多个最大，取最靠后的。
  2. 降序：找到第一个拐点，然后从拐点后找到一个最大的值，一样，如果有多个最大值需要最靠后的。然后将找到的最大值和降序的那一段逐个比较，遇到第一个比它小的直接交换返回即可。

剑指Offer不用加减乘除做加法

- 题目描述

  写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

- ACcode

  ```java
  public class Solution {
      public int Add(int num1,int num2) {
          int sum=0;
          int tmp=0;
          do
          {
              sum=num1^num2;
              tmp=num1&num2;
              tmp=tmp<<1;
              num1=sum;
              num2=tmp;
          }while(num2!=0);
          return num1;
      }
  }
  ```

  

- 解题思路

  这道题目不让用十进制加减乘除，那么只能用二进制的位运算来解决了。

  假如3+1；

  3的二进制：11

  1的二进制：01

  4的二进制：100

  首先是每一位进行相加，没有进位会得到10，进位的话就用与运算求得都是1的位置后在左移一位进行计算。

迷宫寻路

- 题目描述

  假设一个探险家被困在了地底的迷宫之中，要从当前位置开始找到一条通往迷宫出口的路径。迷宫可以用一个二维矩阵组成，有的部分是墙，有的部分是路。迷宫之中有的路上还有门，每扇门都在迷宫的某个地方有与之匹配的钥匙，只有先拿到钥匙才能打开门。请设计一个算法，帮助探险家找到脱困的最短路径。如前所述，迷宫是通过一个二维矩阵表示的，每个元素的值的含义如下  0-墙，1-路，2-探险家的起始位置，3-迷宫的出口，大写字母-门，小写字母-对应大写字母所代表的门的钥匙

  输入描述:

  ```
  迷宫的地图，用二维矩阵表示。第一行是表示矩阵的行数和列数M和N
  后面的M行是矩阵的数据，每一行对应与矩阵的一行（中间没有空格）。M和N都不超过100, 门不超过10扇。
  ```

  输出描述:

  ```
  路径的长度，是一个整数
  ```

- ACcode

  ```java
  import java.util.*;
  public class Main{
  
      void solve()
      {
          int m=0,n=0;
          Scanner scan=new Scanner(System.in);
          m=scan.nextInt();
          n=scan.nextInt();
          boolean [][][]flag=new boolean[m+2][n+2][1024+1];
          char [][]mp=new char[m+2][n+2];
          int startx=0,starty=0;
          int endx=0,endy=0;
          int [][]dir={{0,1},{1,0},{0,-1},{-1,0}};
          for(int i=0;i<m+2;i++)
              for(int j=0;j<n+2;j++)
                  Arrays.fill(flag[i][j],false);
          for(int i=1;i<=m;i++)
          {
              String str=scan.next();
              for(int j=1;j<=n;j++)
              {
                  mp[i][j]=str.charAt(j-1);
                  if(mp[i][j]=='2'){startx=i;starty=j;}
                  if(mp[i][j]=='3'){endx=i;endy=j;}
              }
          }
          Queue<node> queue=new LinkedList<>();
          queue.add(new node(startx,starty));
          flag[startx][starty][0]=true;
          while(!queue.isEmpty())
          {
              node tmp=queue.poll();
              for(int i=0;i<4;i++)
              {
                  int nx=tmp.x+dir[i][0];
                  int ny=tmp.y+dir[i][1];
                  if(nx<=0 || nx>m || ny<=0 || ny>n)continue;
                  if(flag[nx][ny][tmp.keys])continue;
                  if(mp[nx][ny]=='0')continue;
                  if(mp[nx][ny]=='3'){System.out.println(tmp.step+1);return ;}
                  else if(mp[nx][ny]>='a' && mp[nx][ny]<='z')
                  {
                      int key=(int)mp[nx][ny]-'a';
                      int k=1;
                      k=k<<key;
                      node p=new node(nx,ny);
                      p.step=tmp.step+1;
                      p.keys=tmp.keys;
                      p.keys|=k;
                      flag[p.x][p.y][p.keys]=true;
                      queue.add(p);
                  }
                  else if(mp[nx][ny]>='A' && mp[nx][ny]<='Z')
                  {
                      int key=(int)mp[nx][ny]-'A';
                      int k=1;
                      k=k<<key;
                      if((tmp.keys&k)!=0)
                      {
                          node p=new node(nx,ny);
                          p.keys=tmp.keys;
                          p.step=tmp.step+1;
                          flag[p.x][p.y][p.keys]=true;
                          queue.add(p);
                      }
                  }
                  else 
                  {
                      node p=new node(nx,ny);
                      p.step=tmp.step+1;
                      p.keys=tmp.keys;
                      flag[p.x][p.y][p.keys]=true;
                      queue.add(p);
                  }
              }
          }
          System.out.println(-1);
          return ;
      }
      public static void main(String []args)
      {
          Main s=new Main();
          s.solve();
      }
  }
  class node
  {
      int x;
      int y;
      int keys;
      int step;
      node(int x,int y)
      {
          this.x=x;
          this.y=y;
          keys=0;
          step=0;
      }
  
  }
  ```

  

- 解题思路

  这道题是迷宫中最短的步数，用bfs可以处理这个问题，但是由于这道题是需要钥匙开锁，所以再添加一维记录状态，如果对于某一个位置，其当前记录的钥匙状态之前出现过了就无法再走。由于只有10个钥匙，所以就只有1024种状态，通过位与位或运算来计算钥匙。

## 对称二叉树

- 题目描述

  请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

- ACcode

  ```java
  public class Solution {
      boolean isSymmetrical(TreeNode pRoot)
      {
          return isSolve(pRoot,pRoot);
      }
      boolean isSolve(TreeNode root1,TreeNode root2)
      {
          if(root1==null && root2==null)return true;
          if(root1==null || root2==null)return false;
          if(root1.val!=root2.val)return false;
          return isSolve(root1.left,root2.right) && isSolve(root1.right,root2.left;
      }
  }
  ```

- 解题思路

  如果一棵二叉树是对称的，其前序遍历先遍历左节点再遍历右节点和先遍历右节点再遍历左节点是一样的。这里还要注意null，null也要算在序列中。

## 正则表达式匹配

- 题目描述

  请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 
  在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

- ACcode

  ```java
  public class Solution {
      public boolean match(char[] str, char[] pattern)
      {
          if(str.length==0 && pattern.length==0)return true;
          //if(str.length==0 || pattern.length==0)return false;
          return solve(str,pattern,0,0);
      }
      boolean solve(char []str,char []pattern ,int i,int j)
      {
          if(i==str.length && j==pattern.length)return true;
          if(i!=str.length && j==pattern.length)return false;
          if(j+1<pattern.length)
          {
              if(pattern[j+1]=='*')
              {
                  if((i<str.length && pattern[j]==str[i]) || (pattern[j]=='.' && i<str.length))
                  {
                      return solve(str,pattern,i+1,j+2) || solve(str,pattern,i,j+2) || solve(str,pattern,i+1,j);
                  }
                  else
                      return solve(str,pattern,i,j+2);
              }
              if((i<str.length && str[i]==pattern[j]) || pattern[j]=='.')return solve(str,pattern,i+1,j+1);
              return false;
          }
          else
          {
              if(i<str.length)
              {
                  if(str[i]==pattern[j] || pattern[j]=='.')return solve(str,pattern,i+1,j+1);
                  else return false;
              }
              else
              {
                  if(pattern[j]!='*')return false;
                  else return solve(str,pattern,i+1,j+1);
              }
          }
      }
  }
  ```

  

- 解题思路

  这道题的难点在于“*”,所以对于\*有多种判断，要么跳过，要么保留待在原地，要么只待一次。

## 堆棋子

- 题意

  小易将n个棋子摆放在一张无限大的棋盘上。第i个棋子放在第x[i]行y[i]列。同一个格子允许放置多个棋子。每一次操作小易可以把一个棋子拿起并将其移动到原格子的上、下、左、右的任意一个格子中。小易想知道要让棋盘上出现有一个格子中至少有i(1  ≤ i ≤ n)个棋子所需要的最少操作次数.

  输入描述:

  ```
  输入包括三行,第一行一个整数n(1 ≤ n ≤ 50),表示棋子的个数
  第二行为n个棋子的横坐标x[i](1 ≤ x[i] ≤ 10^9)
  第三行为n个棋子的纵坐标y[i](1 ≤ y[i] ≤ 10^9)
  ```

  输出描述:

  ```
  输出n个整数,第i个表示棋盘上有一个格子至少有i个棋子所需要的操作数,以空格分割。行末无空格
  
  如样例所示:
  对于1个棋子: 不需要操作
  对于2个棋子: 将前两个棋子放在(1, 1)中
  对于3个棋子: 将前三个棋子放在(2, 1)中
  对于4个棋子: 将所有棋子都放在(3, 1)中
  ```

   示例1 

  输入

  复制

  ```
  4
  1 2 4 9
  1 1 1 1
  ```

  输出

  复制

  ```
  0 1 3 10
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
      void solve()
      {
          Scanner scan=new Scanner(System.in);
  		int n=scan.nextInt();
  		int []x=new int[n];
  		int []y=new int [n];
  		int []result=new int[n];
  		for(int i=0;i<n;i++)result[i]=Integer.MAX_VALUE;
  		for(int i=0;i<n;i++)x[i]=scan.nextInt();
  		for(int i=0;i<n;i++)y[i]=scan.nextInt();
  		for(int i=0;i<n;i++)
  		{
  			for(int j=0;j<n;j++)
  			{
  				int []arr=new int[n];
  				for(int k=0;k<n;k++)
  				{
  					int dx=x[k]-x[i];
  					int dy=y[k]-y[j];
  					dx=dx<0?-dx:dx;
  					dy=dy<0?-dy:dy;
  					arr[k]=dx+dy;
  				}
  				Arrays.sort(arr);
  				int count=0;
  				for(int k=0;k<n;k++)
  				{
  					count+=arr[k];
  					result[k]=result[k]>count?count:result[k];
  				}
  			}
  		}
  		for(int i=0;i<n-1;i++)
  			System.out.print(result[i]+" ");
  		System.out.println(result[n-1]);
  		return ;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路

  这道题刚开始看的时候没有什么思路。后来是看了题解才做出来的。

  首先对于该问题的所有解，都应该在给定点的x、y坐标的组合之间。也就是下图的所有红色的点。

  ![1553677316385](F:\javaLearning\java\教程\%5CUsers%5C76104%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553677316385.png)

  证明：

  前提：x、y轴坐标是相互独立的。

  先看x轴。假设有一个点x0，那么在x0左边的点有a个，在x0右边有b个。并且a>b。那么必定有一个点x0-1是使所有点到该点的距离最小。因为a>b，那么将点往左移，左边的所有点一共缩短了a，而，右边的所有点增加了b。-a+b<0，所以整体来说是减小的。所以思路就是求出每个点到上述红色点的距离，然后排序，即可。这里的距离用曼哈顿距离即可。

## 小易喜欢的数列

- 题目描述

  小易非常喜欢拥有以下性质的数列:
   1、数列的长度为n
   2、数列中的每个数都在1到k之间(包括1和k)
   3、对于位置相邻的两个数A和B(A在B前),都满足(A <= B)或(A mod B != 0)(满足其一即可)
   例如,当n = 4, k = 7
   那么{1,7,7,2},它的长度是4,所有数字也在1到7范围内,并且满足第三条性质,所以小易是喜欢这个数列的
   但是小易不喜欢{4,4,4,2}这个数列。小易给出n和k,希望你能帮他求出有多少个是他会喜欢的数列。

  输入描述:

  ```
  输入包括两个整数n和k(1 ≤ n ≤ 10, 1 ≤ k ≤ 10^5)
  ```

  输出描述:

  ```
  输出一个整数,即满足要求的数列个数,因为答案可能很大,输出对1,000,000,007取模的结果。
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
  	private final long mod=1000000007;
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		int n=scan.nextInt();
  		int k=scan.nextInt();
  		long [][]dp=new long[n+2][k+2];
  		for(int i=1;i<=k;i++)dp[1][i]=1;
  		for(int i=2;i<=n;i++)
  		{
  			long sum=0;
  			for(int j=1;j<=k;j++)
  			{
  				sum+=dp[i-1][j];
  				sum%=mod;
  			}
  			for(int j=1;j<=k;j++)
  			{
  				long sum2=0;
  				for(int t=j+j;t<=k;t+=j)
  				{
  					sum2+=dp[i-1][t];
  					sum2%=mod;
  				}
  				dp[i][j]=(sum-sum2)%mod;
  			}
  		}
  		long ans=0;
  		for(int i=1;i<=k;i++)
  		{
  			ans+=dp[n][i];
  			ans%=mod;
  		}
  		System.out.println(ans);
  		return ;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```


- 解题思路：

  这道题是一道动态规划的题目，dp\[i\]\[j\]代表长度为i尾数为j的数列。

  状态转移方程为：dp\[i\]\[j\]=长度为i-1的数列总数 减 长度为i-1的数列总数是j的倍数的个数。

  思想比较简单，但是做的时候没有想到。

  假设我已经计算好dp\[i\]\[j\]了，那么，我现在要往后面插入一个数，那么就会有sum（dp[i])个数列产生，但是由于题目中规定前面的数不能是j的倍数，所以需要剔除那些尾数是j的倍数的数列。

## 排序

- 题目描述

  牛牛有一个长度为n的整数序列,牛牛想对这个序列进行重排为一个非严格升序序列。牛牛比较懒惰,他想移动尽量少的数就完成重排,请你帮他计算一下他最少需要移动多少个序列中的元素。(当一个元素不在它原来所在的位置,这个元素就是被移动了的)

  输入描述:

  ```
  输入包括两行,第一行一个整数n(1 ≤ n ≤ 50),即序列的长度
  第二行n个整数x[i](1 ≤ x[i] ≤ 100),即序列中的每个数
  ```

  输出描述:

  ```
  输出一个整数,即最少需要移动的元素个数
  ```

   示例1 

  输入

  复制

  ```
  3
  3 2 1
  ```

  输出

  复制

  ```
  2
  ```

- ACcode

  ```java
  		Scanner scan=new Scanner(System.in);
  		int n=scan.nextInt();
  		int []x=new int [n];
  		int []tmp=new int[n];
  		for(int i=0;i<n;i++){x[i]=scan.nextInt();tmp[i]=x[i];}
  		Arrays.sort(tmp);
  		int ans=0;
  		for(int i=0;i<n;i++)
  		{
  			if(tmp[i]!=x[i])ans++;
  		}
  		System.out.println(ans);
  ```

  

- 解题思路

  这道题是只要换一下就算。思路就是先排个序，如果排好序后的位置的元素如果与原始的元素不一样则+1.

  因为如果排好序后的元素如果与最初该位置的元素不一样，那么必须要交换一次。

## 拼凑正方形

- 题目意思

  牛牛有4根木棍,长度分别为a,b,c,d。羊羊家提供改变木棍长度的服务,如果牛牛支付一个硬币就可以让一根木棍的长度加一或者减一。牛牛需要用这四根木棍拼凑一个正方形出来,牛牛最少需要支付多少硬币才能让这四根木棍拼凑出正方形。

  输入描述:

  ```
  输入包括一行,四个整数a,b,c,d(1 ≤ a,b,c,d ≤ 10^6), 以空格分割
  ```

  输出描述:

  ```
  输出一个整数,表示牛牛最少需要支付的硬币
  ```

   示例1 

  输入

  复制

  ```
  4 1 5 4
  ```

  输出

  复制

  ```
  4
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
  	private final long mod=1000000007;
  	private boolean []isPrime;
  	private int []prime;
  	void createPrimeTable(int maxn)
  	{
  		isPrime=new boolean[maxn+1];
  		prime=new int[maxn+1];
  		Arrays.fill(isPrime,true);
  		int primeNum=0;
  		for(int i=2;i<=maxn;i++)
  		{
  			if(!isPrime[i])continue;
  			prime[primeNum++]=i;
  			for(int j=i+i;j<=maxn;j+=i)isPrime[j]=false;
  		}
  	}
  	boolean isBT(String str)
  	{
  		int i=0;
  		int j=str.length()-1;
  		while(i<=j)
  		{
  			if(str.charAt(i)!=str.charAt(j))return false;
  			i++;
  			j--;
  		}
  		return true;
  	}
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		int []a=new int [4];
  		for(int i=0;i<4;i++)
  			a[i]=scan.nextInt();
  		Arrays.sort(a);
  		int center=a[1];
  		int ans=0;
  		for(int i=0;i<4;i++)
  			ans+=Math.abs(a[i]-center);
  		System.out.println(ans);
  		return ;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路

  直接选取第二条作为正方形的边即可。

  为什么？

  ![1554023071078](F:\javaLearning\java\教程\%5CUsers%5C76104%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1554023071078.png)



## 二叉搜索树与双向链表

- 题目意思

  输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

- ACcode

  ```java
  /**
  public class TreeNode {
      int val = 0;
      TreeNode left = null;
      TreeNode right = null;
  
      public TreeNode(int val) {
          this.val = val;
  
      }
  
  }
  */
  public class Solution {
      TreeNode last=new TreeNode(1);
      public TreeNode Convert(TreeNode pRootOfTree) {
          if(pRootOfTree==null)return null;
          solve(pRootOfTree);
          while(last.left!=null)last=last.left;
          last=last.right;
          last.left=null;
          return last;
      }
      void solve(TreeNode root)
      {
          if(root==null)return ;
          solve(root.left);
          root.left=last;
          last.right=root;
          last=root;
          solve(root.right);
      }
  }
  ```

  

- 解题思路

  这道题用java做有一个坑点就是，java是按值传递的，你可以运行以下代码看看,输出的值为1。

  ```java
  int ss=0;
  void t1(Main mm)
  	{
  		Main mt=new Main();
  		mt.ss=11;
  		mm=mt;
  		return ;
  	}
      void solve()
      {
  		Main mm=new Main();
  		mm.ss=1;
  		t1(mm);
  		System.out.println(mm.ss);
  		return ;
      }
  ```

  如果是直接修改mm.ss的值的话，相当于直接对堆中的实例直接修改，但是如果在函数中直接改变mm的指向的话，返回到solve函数中将没有改变，所以java是按值传递的。



## 疯狂序列

- 题目意思

  东东从京京那里了解到有一个无限长的数字序列: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, ...(数字k在该序列中正好出现k次)。东东想知道这个数字序列的第n项是多少,你能帮帮他么

  输入描述:

  ```
  输入包括一个整数n(1 ≤ n ≤ 10^18)
  ```

  输出描述:

  ```
  输出一个整数,即数字序列的第n项
  ```

   示例1 

  输入

  复制

  ```
  169
  ```

  输出

  复制

  ```
  18
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
  	public long BIG=1500000000;
  	long sum(long start,long end)
  	{
  		long tmp=((start+end)*(end-start+1))>>1;
  		return tmp;
  	}
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		long n=scan.nextLong();
  		long ans=0;
  		long start=1;
  		long end=BIG;
  		while(start<end)
  		{
  			long mid=(start+end)>>1;
  			ans=sum(start,mid);
  			if(n>ans){start=mid+1;n-=ans;}
  			else end=mid;
  		}
  		System.out.println(start);
  		return;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路

  思路就是二分法，但是这里有一个问题就是我在求和公式时，如果先除2不对，因为可能会向下取整，所以先乘再除2.

## 回文

- 题目描述

  京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜,先取定一个字符串s,然后在后面附上0个或者更多个字母形成回文,京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。

  输入描述:

  ```
  输入包括一个字符串s,字符串s长度length(1 ≤ length ≤ 50)
  ```

  输出描述:

  ```
  输出一个整数,表示牛牛能够得到的最短的回文长度。
  ```

   示例1 

  输入

  复制

  ```
  abab
  ```

  输出

  复制

  ```
  5
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
  	public long BIG=1500000000;
  	long sum(long start,long end)
  	{
  		long tmp=((start+end)*(end-start+1))>>1;
  		return tmp;
  	}
  	boolean isSub(String str)
  	{
  		int i=0,j=str.length()-1;
  		while(i<=j)
  		{
  			if(str.charAt(i)==str.charAt(j))
  			{
  				i++;
  				j--;
  			}
  			else
  				return false;
  		}
  		return true;
  	}
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		String str=scan.next();
  		int ans=0;
  		for(int i=0;i<str.length();i++)
  		{
  			if(isSub(str.substring(i)))
  				break;
  			else ans++;
  		}
  		ans+=str.length();
  		System.out.println(ans);
  		return;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路

  这道题的思路是根据网上的一位网友提供的，虽然他的代码有问题，但是思路基本上是对的，只是再比较回文的时候应该从i到最后一位而不是从i到倒数第i位。

  思路：由于前i位我都可以通过在尾巴进行插入，所以我只需要比较从i到末尾是否是回文串就行了。

## 括号匹配方案

- 题目描述

  合法的括号匹配序列被定义为:
   1. 空串""是合法的括号序列
   2. 如果"X"和"Y"是合法的序列,那么"XY"也是一个合法的括号序列
   3. 如果"X"是一个合法的序列,那么"(X)"也是一个合法的括号序列
   4. 每个合法的括号序列都可以由上面的规则生成
   例如"", "()", "()()()", "(()())", "(((())))"都是合法的。 东东现在有一个合法的括号序列s,一次移除操作分为两步:
   1. 移除序列s中第一个左括号
   2. 移除序列s中任意一个右括号.保证操作之后s还是一个合法的括号序列
   东东现在想知道使用上述的移除操作有多少种方案可以把序列s变为空
   如果两个方案中有一次移除操作移除的是不同的右括号就认为是不同的方案。
   例如: s = "()()()()()",输出1, 因为每次都只能选择被移除的左括号所相邻的右括号.
   s = "(((())))",输出24, 第一次有4种情况, 第二次有3种情况, ... ,依次类推, 4 * 3 * 2 * 1 = 24

  输入描述:

  ```
  输入包括一行,一个合法的括号序列s,序列长度length(2 ≤ length ≤ 20).
  ```

  输出描述:

  ```
  输出一个整数,表示方案数
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		String str=scan.next();
  		int count=0;
  		int ans=1;
  		for(int i=0;i<str.length();i++)
  		{
  			if(str.charAt(i)=='(')
  			{
  				count++;
  			}
  			else
  			{
  				ans*=count;
  				count--;
  			}
  		}
  		System.out.println(ans);
  		return;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路

  这道题的思路和括号匹配很像，需要仔细观察才能发现，首先如果有括号嵌套的话，遇到右括号可以删除前面嵌套中的左括号与之任意匹配的右括号，所以就是count种可能性，然后每次遇到右括号先乘再减就行了。

## 求数组中的数能否有组合等于某一个数

- 题目描述

  数组中的数任意组合的和能否等于某一个数sum

- ACcode

  ```java
  boolean dfs(int i,int sum,ArrayList<Integer> arr)
  	{
  		if(sum==0)return true;
  		if(i>=arr.size())return false;
  		if(sum<0)return false;
  		return dfs(i+1,sum,arr) || dfs(i+1,sum-arr.get(i),arr);
  	}
  ```

  



## 青草游戏

- 题目描述

  牛牛和羊羊都很喜欢青草。今天他们决定玩青草游戏。
    最初有一个装有n份青草的箱子,牛牛和羊羊依次进行,牛牛先开始。在每个回合中,每个玩家必须吃一些箱子中的青草,所吃的青草份数必须是4的x次幂,比如1,4,16,64等等。不能在箱子中吃到有效份数青草的玩家落败。假定牛牛和羊羊都是按照最佳方法进行游戏,请输出胜利者的名字。

  输入描述:

  ```
  输入包括t+1行。
  第一行包括一个整数t(1 ≤ t ≤ 100),表示情况数.
  接下来t行每行一个n(1 ≤ n ≤ 10^9),表示青草份数
  ```

  输出描述:

  ```
  对于每一个n,如果牛牛胜利输出"niu",如果羊羊胜利输出"yang"。
  ```

   示例1 

  输入

  复制

  ```
  3
  1
  2
  3
  ```

  输出

  复制

  ```
  niu
  yang
  niu
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
  	HashMap<Integer,Boolean> mp=new HashMap<>();
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		int n=scan.nextInt();
  		for(int i=0;i<n;i++)
  		{
  			int t=scan.nextInt();
  			int tmp=t%5;
  			if(tmp==1 || tmp==4 || tmp==3)System.out.println("niu");
  			else System.out.println("yang");
  		}
  		return;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路：

  这道题是一道博弈论的题目。

  需要mod5来思考。

  1. 首先来看0（mod5）的情况：对于这种情况，无论牛牛取1还是4都会输。.。

  2. 1（mod5）的情况：牛牛只要先取1个，变成0（mod5）的情况，此时变成先手必败状态，此时牛牛会胜。

  3. 2（mod5）的情况：此时牛牛只能将其变成1（mod5） or 3（mod5）的情况，变成1（mod5）先手必胜，牛牛选了只能输。牛牛选择4变成3（mod5）的情况，那么羊羊可以选择1变成2（mod5）的情况，一直到只有两个草的时候羊羊胜。

  4. 3（mod）5，此时牛牛可以吃一个草，这时变成2（mod5），先手必败状态，牛牛胜。

  5. 4（mod）5，此时牛牛可以将草变成0（mod5），此时先手必败，牛牛胜。

     具体网址：https://blog.csdn.net/huyahuioo/article/details/80081031



## 幸运子序列

- 题目描述

  牛牛得到一个长度为n的整数序列V,牛牛定义一段连续子序列的幸运值为这段子序列中最大值和次大值的异或值(次大值是严格的次大)。牛牛现在需要求出序列V的所有连续子序列中幸运值最大是多少。请你帮帮牛牛吧。

  输入描述:

  ```
  第一行一个整数n,即序列的长度。(2<= n <= 100000)
  第二行n个数，依次表示这个序列每个数值V[i], (1 ≤ V[i] ≤ 10^8)且保证V[1]到V[n]中至少存在不同的两个值.
  ```

  输出描述:

  ```
  输出一个整数,即最大的幸运值
  ```

   示例1 

  输入

  复制

  ```
  5
  5 2 1 4 3
  ```

  输出

  复制

  ```
  7
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  import java.io.*;
  public class Main{
      void solve()
      {
          Scanner scan=new Scanner(System.in);
          int n=scan.nextInt();
          int []a=new int[n];
          for(int i=0;i<n;i++)a[i]=scan.nextInt();
          Stack<Integer>stack=new Stack<>();
          int mmax=-1;
          for(int i=0;i<n;i++)
          {
              while(!stack.isEmpty() && stack.peek()<=a[i])stack.pop();
              if(!stack.isEmpty())mmax=Math.max(mmax,stack.peek()^a[i]);
              stack.push(a[i]);
          }
          stack.clear();
          for(int i=n-1;i>=0;i--)
          {
              while(!stack.isEmpty() && stack.peek()<=a[i])stack.pop();
              if(!stack.isEmpty())mmax=Math.max(mmax,a[i]^stack.peek());
              stack.push(a[i]);
          }
          System.out.println(mmax);
      }
      public static void main(String []args)
      {
          Main mm=new Main();
          mm.solve();
      }
  }
  ```

  

- 解题思路

  这道题在做的时候稍微有些思路，但是就是没有做出来。

  这道题是求在某一个连续的子序列中最大的数和次大的数的异或值。那么对于给定数组的每一个数，如果其作为次大的数在某一些序列中，那么就是向左和向右找第一个大于它的数做异或。

  找向左或向右第一个比他大的数可以使用单调栈。

  单调栈：如果我（当前值）比栈顶的元素还大那么栈顶元素可以不要了，因为我比它大，那后面的元素如果能找栈顶元素，那也能找我。



## 红和绿

- 题目描述

  牛牛有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。牛牛现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将会被覆盖。牛牛的目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。牛牛想知道他最少需要涂染几个正方形。
   如样例所示: s = RGRGR
   我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。

  输入描述:

  ```
  输入包括一个字符串s,字符串s长度length(1 ≤ length ≤ 50),其中只包括'R'或者'G',分别表示红色和绿色。
  ```

  输出描述:

  ```
  输出一个整数,表示牛牛最少需要涂染的正方形数量
  ```

   示例1 

  输入

  复制

  ```
  RGRGR
  ```

  输出

  复制

  ```
  2
  ```

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main{
      void solve()
      {
  		Scanner scan=new Scanner(System.in);
  		String str=scan.next();
  		int count=0;
  		int gcount=0;
  		for(int i=0;i<str.length();i++)
  		{
  			if(str.charAt(i)=='G')
  			{
  				gcount++;
  			}
  			else
  			{
  				count=Math.min(gcount,count+1);
  			}
  		}
  		System.out.println(count);
  		return;
      }
      public static void main(String []args)
      {
          Main m=new Main();
          m.solve();
      }
  }
  ```

  

- 解题思路

  `在当前位置为R时有可能两种情况,一种是吧这个位置编程G,另一种是吧前面的G全部变成R.`

## 连续子数组的问题

求连续子数组的和。可以用一个集合来记录从0~i-1的和，然后用nums[i]+{x|set(x)}.

```java
 public boolean checkSubarraySum(int[] nums, int k) {
        TreeSet<Integer> set=new TreeSet<>();
        for(int i=0;i<nums.length;i++)
        {
            TreeSet<Integer>s_tmp=new TreeSet<>();
            for(Integer cur:set)
            {
                int sum=cur+nums[i];
                if(sum==0 && k==0)return true;
                if(k!=0 && sum%k==0)return true;
                s_tmp.add(sum);
            }
            s_tmp.add(nums[i]);
            set=s_tmp;
        }
        return false;
    }
```





## 最长递增子序列的个数

- 题目描述

  给定一个未排序的整数数组，找到最长递增子序列的个数。

  **示例 1:**

  ```
  输入: [1,3,5,4,7]
  输出: 2
  解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
  ```

  **示例 2:**

  ```
  输入: [2,2,2,2,2]
  输出: 5
  解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
  ```

- ACcode

  ```java
  class Solution {
      public int findNumberOfLIS(int[] nums) {
          if(nums.length==0)return 0;
          int mmin=nums[0];
          int mcur=0;
          for(int i=1;i<nums.length;i++)
          {
              if(nums[i]<mmin){mcur=i;mmin=nums[i];}
          }
          int []dp=new int[nums.length];
          int []maxNum=new int[nums.length];
          Arrays.fill(dp,1);
          Arrays.fill(maxNum,1);
          int ans=1;
          int maxLen=1;
          for(int i=1;i<nums.length;i++)
          {
              int curMax=1;
              int curLen=1;
              for(int j=0;j<i;j++)
              {
                  if(nums[i]>nums[j])
                  {
                      int tmp=dp[j]+1;
                      dp[i]=Math.max(dp[i],tmp+1);
                      if(tmp>curLen)
                      {
                          curMax=maxNum[j];
                          curLen=tmp;
                      }
                      else if(tmp==curLen)
                      {
                          curMax+=maxNum[j];
                      }
                  }
              }
              maxNum[i]=curMax;
              if(maxLen<curLen)
              {
                  maxLen=curLen;
                  ans=curMax;
              }
              else if(maxLen==curLen){ans+=curMax;}
          }
          if(maxLen==1)ans=nums.length;
          return ans;
      }
  }
  ```

  

- 解题思路

  这道题的思路很简单，但是就是做的时候没考虑很多细节的东西，导致wa了很多次。

  要注意记录当前的状态，而不是全局的状态。

## Leetcode464

- 题目描述

  在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。

  如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？

  例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

  给定一个整数 `maxChoosableInteger` （整数池中可选择的最大数）和另一个整数 `desiredTotal`（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？

  你可以假设 `maxChoosableInteger` 不会大于 20， `desiredTotal` 不会大于 300。

  **示例：**

  ```
  输入：
  maxChoosableInteger = 10
  desiredTotal = 11
  
  输出：
  false
  
  解释：
  无论第一个玩家选择哪个整数，他都会失败。
  第一个玩家可以选择从 1 到 10 的整数。
  如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
  第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
  同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
  ```

- ACcode

  ```java
  class Solution {
      int []dp;
      public boolean canIWin(int m, int d) {
          if(d<=m)return true;
          if(d>(((1+m)*m)/2))return false;
          dp=new int[1<<m+1];
          Arrays.fill(dp,-1);
          return solve(m,d,0);
      }
      boolean solve(int max,int dir,int visited)
      {
          if(dp[visited]!=-1)return dp[visited]==1?true:false;
          for(int i=1;i<=max;i++)
          {
              int mask=1<<(i-1);
              if(((mask&visited)==0) && (i>=dir || !solve(max,dir-i,visited|mask)))
              {
                  dp[visited]=1;
                  return true;
              }
          }
          dp[visited]=0;
          return false;
      }
  }
  ```

  

- 解题思路

  这道题是一道博弈论+dp（状态压缩）的题。

  首先判断目标值是否小于最大值，是的话先手必胜。

  其次判断目标值是否大于所有数的总和，是的话谁都不可能赢。

  暴力遍历每一种状态，利用状态压缩，如果当前状态没出现过，则进行遍历池中所有没取过的数：如果当前数大于目标状态，那肯定直接取获胜，否则判断对手是否会输来判断自己能否获胜。如果遍历完所有状态还不能获胜则输。

  

  

## 猜数字大小

- 题目描述

  我们正在玩一个猜数游戏，游戏规则如下：

  我从 **1** 到 **n** 之间选择一个数字，你来猜我选了哪个数字。

  每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

  然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

  **示例:**

  ```
  n = 10, 我选择了8.
  
  第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
  第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
  第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。
  
  游戏结束。8 就是我选的数字。
  
  你最终要支付 5 + 7 + 9 = 21 块钱。
  ```

- ACcode

  ```java
  class Solution {
      int [][]dp=null;
      public int getMoneyAmount(int n) {
          dp=new int[n+1][n+1];
          for(int i=0;i<dp.length;i++)
              Arrays.fill(dp[i],Integer.MAX_VALUE);
          return solve(1,n);
      }
      int solve(int from,int to)
      {
          if(from>=to)return 0;
          if(dp[from][to]!=Integer.MAX_VALUE)return dp[from][to];
          for(int i=from;i<=to;i++)
          {
              int left=solve(from,i-1);
              int right=solve(i+1,to);
              int tmp=i+Math.max(left,right);
              dp[from][to]=Math.min(dp[from][to],tmp);
          }
          return dp[from][to];
      }
  }
  ```

  

- 解题思路

  这道题的出发点应该从选取的每个数进行选取，从from到to每个都选一遍那么结果就是i+max(left,right)，计算选i最多需要多少花费，然后再选组从from到to的最小花费。

  https://www.cnblogs.com/zichi/p/5701194.html



## 子数组的最小值之和

- 题目意思

  给定一个整数数组 `A`，找到 `min(B)` 的总和，其中 `B` 的范围为 `A` 的每个（连续）子数组。

  由于答案可能很大，因此**返回答案模 10^9 + 7**。

   

  **示例：**

  ```
  输入：[3,1,2,4]
  输出：17
  解释：
  子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
  最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
  ```

   

  **提示：**

  1. `1 <= A <= 30000`
  2. `1 <= A[i] <= 30000`

   

- ACcode

  ```java
  class Solution {
      int mod=1000000007;
      public int sumSubarrayMins(int[] A) {
          Stack<Integer>stack=new Stack<>();
          int ans=0;
          for(int i=0;i<A.length;i++)
          {
              while(!stack.isEmpty() && A[stack.peek()]>=A[i])stack.pop();
              int left=stack.isEmpty()?-1:stack.peek();
              int right=i+1;
              while(right<A.length && A[right]>=A[i])right++;
              int num=(((i-left)*(right-i-1)%mod)+(i-left))%mod;
              stack.push(i);
              ans+=A[i]*num;
              ans%=mod;
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  这道题是枚举每一个位置i，计算以他为最小值的子数组。用单调栈维护从i开始往前的最小值。

  这里我遇到两个坑：

  1. 首先是计算前后子数组的长度。

     例如：0 1 2 3 4 5 6，left=0，right=6

     1 2 3      4  5

     2 3         4  5

     3            4  5

     1 2 3

     2 3

     3

     所以是：
     $$
     (i-left)*(right-i-1)+(i-left)
     $$

  2. 然后是往前找最小值不能到相等的情况，否则会重复计算。

     例如 3 1 2 1

     我找前面的第一个1的时候就已经计算了后面的1 2 1，如果我到第2个1还计算相等的情况就会重复。

  

## 使序列递增的最小交换次数

- 题目描述

  我们有两个长度相等且不为空的整型数组 `A` 和 `B` 。

  我们可以交换 `A[i]` 和 `B[i]` 的元素。注意这两个元素在各自的序列中应该处于相同的位置。

  在交换过一些元素之后，数组 `A` 和 `B` 都应该是严格递增的（数组严格递增的条件仅为`A[0] < A[1] < A[2] < ... < A[A.length - 1]`）。

  给定数组 `A` 和 `B` ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

  ```
  示例:
  输入: A = [1,3,5,4], B = [1,2,3,7]
  输出: 1
  解释: 
  交换 A[3] 和 B[3] 后，两个数组如下:
  A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
  两个数组均为严格递增的。
  ```

  **注意:**

  - `A, B` 两个数组的长度总是相等的，且长度的范围为 `[1, 1000]`。
  - `A[i], B[i]` 均为 `[0, 2000]`区间内的整数。

- ACcode

  ```java
  class Solution {
      
      public int minSwap(int[] A, int[] B) {
          if(A.length==1)return 0;
          int []swap=new int[A.length];
          int []keep=new int[A.length];
          Arrays.fill(swap,Integer.MAX_VALUE);
          Arrays.fill(keep,Integer.MAX_VALUE);
          swap[0]=1;
          keep[0]=0;
          for(int i=1;i<A.length;i++)
          {
              if(A[i]>A[i-1] && B[i]>B[i-1])
              {
                  keep[i]=keep[i-1];
                  swap[i]=swap[i-1]+1;
              }
              if(A[i]>B[i-1] && B[i]>A[i-1])
              {
                  keep[i]=Math.min(keep[i],swap[i-1]);
                  swap[i]=Math.min(swap[i],keep[i-1]+1);
              }
          }
          return Math.min(swap[A.length-1],keep[A.length-1]);
      }
      
  }
  ```

  

- 解题思路

  ```java
  //!Wrong Answer 不能保证每一个都交换
  class Solution {
      int []dp=null;
      public int minSwap(int[] A, int[] B) {
          dp=new int[A.length];
          if(A.length==1)return 0;
          Arrays.fill(dp,-2);
          return solve(A,B,0,false);
      }
      int solve(int []A,int []B,int cur,boolean flag)
      {
          if(cur==A.length-1)return 0;
          if(!flag && dp[cur]!=-2)return dp[cur];
          if(A[cur]<A[cur+1] && B[cur]<B[cur+1])
          {
              int tmp=solve(A,B,cur+1,false);
              dp[cur]=tmp;
              return dp[cur];
          }
          else
          {
              if(A[cur]<B[cur+1] && B[cur]<A[cur+1])
              {
                  A[cur+1]^=B[cur+1];
                  B[cur+1]^=A[cur+1];
                  A[cur+1]^=B[cur+1];
                  int nochange=solve(A,B,cur+1,false);
                  A[cur+1]^=B[cur+1];
                  B[cur+1]^=A[cur+1];
                  A[cur+1]^=B[cur+1];
                  int change=solve(A,B,cur+1,true);
                  if(change!=-1 && nochange!=-1)
                  {
                      dp[cur]=Math.min(change,nochange)+1;
                  }
                  else if(change!=-1)dp[cur]=change+1;
                  else if(nochange!=-1)dp[cur]=nochange+1;
                  else dp[cur]=-1;
                  return dp[cur];
              }
              else
                  return -1;
          }
      }
  }
  ```

  这道题我最开始想的时候是对于一个位置能不换我就不换，如果能换，我计算换之后和不换哪个较小。

  但是这样有一个问题就是：我无法保证我当前换完后前面也要换的情况。

  看了别人的博客上的思路是：

  对于可以不换的情况：

  如果我换了，那么前i-1个也要换。如果我不换直接等于前i-1个不换的情况。

  对于可以换的情况：

  如果我换了，那么保持前i-1个不动就可以了，同时还要和不换的情况取最小值。

  如果我不换，那么前i-1个都要换。

  两种情况应该同时考虑。

## 多米诺和托米若平铺

- 题目描述

  有两种形状的瓷砖：一种是 2x1 的多米诺形，另一种是形如 "L" 的托米诺形。两种形状都可以旋转。

  ```
  XX  <- 多米诺
  
  XX  <- "L" 托米诺
  X
  ```

  给定 N 的值，有多少种方法可以平铺 2 x N 的面板？**返回值 mod 10^9 + 7**。

  （平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。）

  ```
  示例:
  输入: 3
  输出: 5
  解释: 
  下面列出了五种不同的方法，不同字母代表不同瓷砖：
  XYZ XXZ XYY XXY XYY
  XYZ YYZ XZZ XYY XXY
  ```

- ACcode

  ```java
  class Solution {
      int mod = 1000000007;
      int []dp = null;
      public int numTilings(int N) {
          if(N < 1)
          {
              return 0;
          }
          if(N==1)return 1;
          if(N==2)return 2;
          dp = new int [N+1];
          Arrays.fill(dp,-1);
          dp[2] = 2;
          dp[1] = 1;
          dp[0] = 1;
          return solve(N);
      }
      int solve(int n)
      {
          if(dp[n] != -1)return dp[n];
          int tmp = -1;
          tmp = (solve(n-1)+solve(n-2));
          tmp %= mod;
          int t=0;
          for(int i = 3;i <= n;i++)
          {
              t+=solve(n-i);
              t%=mod;
          }
          t *= 2;
          t %= mod;
          tmp += t;
          tmp %= mod;
          dp[n] = tmp;
          return dp[n];
      }
  }
  ```

  

- 解题思路

  这道题犯了一个比较低级的错误。

  思路：对于普通长方形类型的砖块则和普通的平铺问题一样，但是对于L型的砖块，则需要从3开始累加。

  因为

![1554799993094](C:\Users\76104\AppData\Roaming\Typora\typora-user-images\1554799993094.png)

所以对于L型的砖块需要从3开始网上累加。

状态转移方程：
$$
dp[i] = dp[i-1]+dp[i-2]+2*\sum_{j=3}^{n}dp[i-j];
$$
我犯的错误是我直接在tmp处直接*2，应该是在外面\* 2；



## 乘积最大的子序列

- 题目描述

  给定一个整数数组 `nums` ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

  **示例 1:**

  ```
  输入: [2,3,-2,4]
  输出: 6
  解释: 子数组 [2,3] 有最大乘积 6。
  ```

  **示例 2:**

  ```
  输入: [-2,0,-1]
  输出: 0
  解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
  ```

- ACcode

  ```java
  class Solution {
      public int maxProduct(int[] nums) {
          int []mmin = new int [nums.length];
          int []mmax = new int [nums.length];
          mmin[0] = nums[0];
          mmax[0] = nums[0];
          for(int i=1;i<nums.length;i++)
          {
              mmin[i] = Math.min(nums[i],Math.min(mmin[i-1]*nums[i],mmax[i-1]*nums[i]));
              mmax[i] = Math.max(nums[i],Math.max(mmin[i-1]*nums[i],mmax[i-1]*nums[i]));
          }
          int ans = Integer.MIN_VALUE;
          for(int i=0;i<nums.length;i++)ans=Math.max(ans,Math.max(mmin[i],mmax[i]));
          return ans;
      }
  }
  ```

  

- 解题思路

  思路就是我维护一个最小和一个最大，然后用a[i]来乘取最大。

  递推方程：
  $$
  mmin[i]=min(mmin[i-1]*a[i],a[i],mmax[i-1]*a[i])
  \\
  mmax[i]=max(mmax[i-1]*a[i],a[i],mmin[i-1]*a[i])
  $$
  

  



## 二倍数对数组

- 题目描述

  给定一个长度为偶数的整数数组 `A`，只有对 `A` 进行重组后可以满足 “对于每个 `0 <= i < len(A) / 2`，都有 `A[2 * i + 1] = 2 * A[2 * i]`” 时，返回 `true`；否则，返回 `false`。

   

  **示例 1：**

  ```
  输入：[3,1,3,6]
  输出：false
  ```

  **示例 2：**

  ```
  输入：[2,1,2,6]
  输出：false
  ```

  **示例 3：**

  ```
  输入：[4,-2,2,-4]
  输出：true
  解释：我们可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]
  ```

  **示例 4：**

  ```
  输入：[1,2,4,16,8,4]
  输出：false
  ```

   

  **提示：**

  1. `0 <= A.length <= 30000`
  2. `A.length` 为偶数
  3. `-100000 <= A[i] <= 100000`

- ACcode

  ```java
  class Solution {
      public boolean canReorderDoubled(int[] A) {
          HashMap<Integer,Integer> mp= new HashMap<>();
          for(int i=0;i<A.length;i++)
          {
              if(mp.containsKey(A[i]))
              {
                  int lo = mp.get(A[i]);
                  mp.put(A[i],lo+1);
              }
              else
                  mp.put(A[i],1);
          }
          Arrays.sort(A);
          int split=0;
          for(int i=0;i<A.length;i++)
          {
              if(A[i]<=0)split=i;
              else break;
          }
          if(mp.containsKey(0))
          {
              int tmp = mp.get(0);
              if(tmp%2!=0)return false;
              mp.put(0,0);
          }
          for(int i=0;i<split;i++)
          {
              int tmp = A[i]*2;
              int l = mp.get(A[i]);
              if(l<=0)continue;
              if(mp.containsKey(tmp))
              {
                  int lo = mp.get(tmp);
                  if(lo>0){
                      lo--;
                      mp.put(tmp,lo);
                      int tmpa = mp.get(A[i]);
                      mp.put(A[i],tmpa-1);
                  }
              }
          }
          for(int i=split;i<A.length;i++)
          {
              int tmp = A[i]*2;
              int l = mp.get(A[i]);
              if(l<=0)continue;
              if(mp.containsKey(tmp))
              {
                  int lo = mp.get(tmp);
                  if(lo>0){
                      lo--;
                      mp.put(tmp,lo);
                      int tmpa = mp.get(A[i]);
                      mp.put(A[i],tmpa-1);
                  }
              }
          }
          for(Map.Entry<Integer,Integer>entry:mp.entrySet())
          {
              if(entry.getValue()>0)return false;
          }
          return true;
      }
  }
  ```

  

- 解题思路

  先统计每一个数出现的次数，然后将数组进行排序后按照小于0，等于0，大于0进行分组。

  每一组判断每一个数是否有一个比他大的数和他进行配对，如果有则互相-1。

  0要判断是否为偶数个，是的话为true，否则为false。

  最后判断map中的每个数是否有大于0，有说明没有配对完，返回false.

## 环绕字符串中唯一的子字符串

- 题目描述

  把字符串 `s` 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 `s` 看起来是这样的："...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". 

  现在我们有了另一个字符串 `p` 。你需要的是找出 `s` 中有多少个唯一的 `p` 的非空子串，尤其是当你的输入是字符串 `p` ，你需要输出字符串 `s` 中 `p` 的不同的非空子串的数目。 

  **注意:** `p` 仅由小写的英文字母组成，p 的大小可能超过 10000。

   

  **示例 1:**

  ```
  输入: "a"
  输出: 1
  解释: 字符串 S 中只有一个"a"子字符。
  ```

   

  **示例 2:**

  ```
  输入: "cac"
  输出: 2
  解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.
  ```

   

  **示例 3:**

  ```
  输入: "zab"
  输出: 6
  解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.
  ```

- ACcode

  ```java
  class Solution {
      public int findSubstringInWraproundString(String p) {
          if(p.length()==0)return 0;
          int []arr=new int [p.length()];
          int k=0;
          for(int i=0;i<p.length();i++)arr[k++]=p.charAt(i)-'a';
          int head=arr[0];
          int []dp=new int[26];
          Arrays.fill(dp,0);
          k=0;
          int i=0;
          int start=0;
          while(i<p.length())
          {
              start=i;
              while(i<p.length() && head==arr[i])
              {
                  head=(head+1)%26;
                  i++;
              }
              int len=i-start;
              while(len>0)
              {
                  dp[arr[start]]=Math.max(len,dp[arr[start]]);
                  start++;
                  len--;
              }
              if(i<p.length())
                  head=arr[i];
          }
          int ans=0;
          for(int j=0;j<26;j++)ans+=dp[j];
          return ans;
      }
  }
  ```

  

- 解题思路

  这道题我最初想的是对于每一个连续的子字符串的递推公式是
  $$
  dp[i]=dp[i-1]+1
  $$
  但是这样没有考虑到后面字符串重复出现的情况。

  那么由于是唯一性，所以我可以对于每一个字符来进行一次统计，先对找出连续的子字符串，然后根据当前字符最长连续子串进行记录。
  $$
  dp[arr[i]]=max(dp[arr[i]],len)
  $$




## 阶乘后面0的个数

- 题目描述

  求n！后面0的个数

- ACcode

  ```java
  int getFacotrs(int n,int factor)
  	{
  		if(n<factor)return 0;
  		else return n/factor+getFacotrs(n/factor,factor);
  	}
  ```

  

- 解题思路
  $$
  n!=[5k*5(k-1)*...*10*5]*a \\
  a=\{所有因子的乘积\}\\
  so\\
  n!=5^k*k!*a\\
  另f(n)=n！中末尾0的个数\\
  f(n)=k+f(k)\\
  k=n/5 \ ?\\
  n=5k+r \\
  11=10*5*[2*3*4*6*7*8*9*11]\ \ k=2\\
  
  因为5的个数小于2的个数，所以只需要统计5的个数就行
  $$
  

## 求N！的最右边的数

- 题目描述

  求N！的最右边的数

- code

  ```java
  import java.util.*;
  import java.math.*;
  //hdu error
  public class Main
  {
  	int getFacotrs(int n,int factor)
  	{
  		if(n<factor)return 0;
  		else return n/factor+getFacotrs(n/factor,factor);
  	}
  	void solve()
  	{
  		Scanner scan=new Scanner(System.in);
  		while(scan.hasNext())
  		{
  			int n=scan.nextInt();
  			int factors=getFacotrs(n,5);
  			//System.out.println(factors);
  			int count=0;
  			int result=1;
  			while(n>=1)
  			{
  				int tmp=n;
  				while(tmp%2==0 && count<factors)
  				{
  					tmp/=2;
  					count++;
  				}
  				while(tmp%5==0)
  					tmp/=5;
  				result*=tmp;
  				result%=10;
  				n--;
  			}
  			System.out.println(result);
  		}
  	}
  	
  	public static void main(String[]args)
  	{
  		Main m=new Main();
  		m.solve();
  	}
  }
  class node
  {
  	int x;
  	int step;
  	node(int x)
  	{
  		step=0;
  		this.x=x;
  	}
  }
  
  
  ```

  

- 解题思路

  在笔试的时候我想的是每次只保留最后一位非0数，然后和n相乘，但是我忽略了进位的情况，在15的时候如果不考虑进位14！最右一位非0数为2，15*2=30，但是14！的最右的两位是12，12\*15=180，所以应该为8.出现这个原因是因为有5\*2=10进位了，所以没有保留进位的信息所以出错了。由于5\*2=10去掉0后只剩1，所以没有作用，所以可以将出现10的个数删除，因为5的个数小于2出现的个数，所以计算出5的个数后每次计算前先去掉5和2，再利用前面想的每次保留各位就行了。
  $$
  15!=(3*5)*(7*2)*13*(6*2)*11*(5*2)*9*8*7*6*5*4*3*2
  $$
  

## 是两个字符串相同的最少操作

- 题目描述

  给定两个字符串，可以删除字符，也可以插入字符，也可以修改字符，问最少需要几次操作才能将两个字符串变相同

  例如：

  ```xml
  输入：
  hello
  helle
  
  输出：
  1
  ```

  

- ACcode

  ```java
  import java.util.*;
  import java.math.*;
  public class Main
  {
  	int ans=Integer.MAX_VALUE;
  	void dfs(String str1,String str2,int i,int j,int step)
  	{
  		if(str1.length()==i && str2.length()==j)
  		{
  			ans=Math.min(ans,step);
  			return ;
  		}
  		else if(str1.length()==i)
  		{
  			step+=str2.length()-j;
  			ans=Math.min(ans,step);
  			return;
  		}
  		else if(str2.length()==j)
  		{
  			step+=str1.length()-i;
  			ans=Math.min(ans,step);
  			return;
  		}
  		if(str1.charAt(i)==str2.charAt(j))
  		{
  			dfs(str1,str2,i+1,j+1,step);
  		}
  		
  		dfs(str1,str2,i,j+1,step+1);
  		dfs(str1,str2,i+1,j+1,step+1);
  		dfs(str1,str2,i+1,j,step+1);
  	}
  	void solve()
  	{
  		Scanner scan =new Scanner(System.in);
  		String str1=scan.next();
  		String str2=scan.next();
  		dfs(str1,str2,0,0,0);
  		System.out.println(ans);
  	}
  	
  	public static void main(String[]args)
  	{
  		Main m=new Main();
  		m.solve();
  	}
  }
  class node
  {
  	int x;
  	int step;
  	node(int x)
  	{
  		step=0;
  		this.x=x;
  	}
  }
  
  
  ```

  

- 解题思路

  暴力：

  通过两个指针来指向当前所指的对应字符，如果两个相同，那么我可以选择直接跳过，或者插入删除替换等操作都进行遍历一次，维护最小值。

  如果不相同，则要么i+1,j不动插入或删除，或者i,j+1，i不动，删除j或插入。或者进行替换成相同的，则两者一起+1.

## 适龄的朋友

- 题目描述

  人们会互相发送好友请求，现在给定一个包含有他们年龄的数组，`ages[i]` 表示第 i 个人的年龄。

  当满足以下条件时，A 不能给 B（A、B不为同一人）发送好友请求：

  - `age[B] <= 0.5 * age[A] + 7`
  - `age[B] > age[A]`
  - `age[B] > 100 && age[A] < 100`

  否则，A 可以给 B 发送好友请求。

  注意如果 A 向 B 发出了请求，不等于 B 也一定会向 A 发出请求。而且，人们不会给自己发送好友请求。 

  求总共会发出多少份好友请求?

   

  **示例 1:**

  ```
  输入: [16,16]
  输出: 2
  解释: 二人可以互发好友申请。
  ```

  **示例 2:**

  ```
  输入: [16,17,18]
  输出: 2
  解释: 好友请求可产生于 17 -> 16, 18 -> 17.
  ```

  **示例 3:**

  ```
  输入: [20,30,100,110,120]
  输出: 3
  解释: 好友请求可产生于 110 -> 100, 120 -> 110, 120 -> 100.
  ```

   

  **说明:**

  - `1 <= ages.length <= 20000`.
  - `1 <= ages[i] <= 120`

- ACcode

  ```java
  class Solution {
      public int numFriendRequests(int[] ages) {
        HashMap<Integer,Integer>mp=new HashMap<>();
          for(int i=0;i<ages.length;i++)
          {
              if(mp.containsKey(ages[i]))
              {
                  int tmp=mp.get(ages[i]);
                  mp.put(ages[i],tmp+1);
              }
              else
                  mp.put(ages[i],1);
          }
          int ans=0;
          for(Map.Entry<Integer,Integer> entryi:mp.entrySet())
          {
              for(Map.Entry<Integer,Integer> entryj:mp.entrySet())
              {
                  if((float)entryj.getKey()<=0.5*entryi.getKey()+7 || entryj.getKey()>entryi.getKey() || (entryj.getKey()>100 && entryi.getKey()<100))
                  {
                      continue;
                  }
                  else
                  {
                      if(entryi.getKey()==entryj.getKey()){
                          ans+=entryi.getValue()*(entryj.getValue()-1);
                      }
                      else
                          ans+=entryi.getValue()*entryj.getValue();
                  }
              }
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  注意这道题给的数据1<=ages[i]<=120,1<=ages.length<=20000.所以会有很多重复的计算，重复的计算可以用乘法来直接计算得到。首先用一个HashMap来去重统计出现的次数。一定要先判断是否能够发送朋友请求才判断是否相等，如果相等则需要-1去掉自己，否则的话就是nums[A]*nums[B]。



## 最大正方形

- 题目描述

  在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

  **示例:**

  ```
  输入: 
  
  1 0 1 0 0
  1 0 1 1 1
  1 1 1 1 1
  1 0 0 1 0
  
  输出: 4
  ```

- ACcode

  ```java
  class Solution {
      public int maximalSquare(char[][] matrix) {
          if(matrix.length==0)return 0;
          int [][]dp=new int [matrix.length][matrix[0].length];
          for(int i=0;i<matrix.length;i++)
          {
              for(int j=0;j<matrix[i].length;j++)
              {
                  if(matrix[i][j]=='1')dp[i][j]=1;
              }
          }
          int ans=dp[0][0];
          for(int i=0;i<matrix.length;i++)
          {
              for(int j=0;j<matrix[i].length;j++)
              {
                  ans=Math.max(dp[i][j],ans);
                  if(i-1<0 || j-1<0)continue;
                  if(dp[i][j]==0)continue;
                  if(dp[i][j-1]!=0 && dp[i-1][j]!=0 && dp[i-1][j-1]!=0)
                      dp[i][j]=Math.min(dp[i-1][j-1]+1,Math.min(dp[i-1][j]+1,dp[i][j-1]+1));
                  ans=Math.max(dp[i][j],ans);
              }
          }
          return ans*ans;
      }
  }
  ```

  

- 解题思路

  状态转移方程：
  $$
  dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j],dp[i][j-1])
  $$

## 最大平均值和的分组

- 题目描述

  我们将给定的数组 `A` 分成 `K` 个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。

  注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。

  ```
  示例:
  输入: 
  A = [9,1,2,3,9]
  K = 3
  输出: 20
  解释: 
  A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.
  我们也可以把 A 分成[9, 1], [2], [3, 9].
  这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.
  ```

  **说明:** 

  - `1 <= A.length <= 100`.
  - `1 <= A[i] <= 10000`.
  - `1 <= K <= A.length`.
  - 答案误差在 `10^-6` 内被视为是正确的。

- ACCODE

  ```java
  class Solution {
      public double largestSumOfAverages(int[] A, int K) {
          double [][]dp=new double[K][A.length];
          double ans=0;
          for(int i=0;i<K;i++)
          {
              if(i==0)
              {
                  int num=0;
                  int sum=0;
                  for(int j=0;j<A.length;j++)
                  {
                      num++;
                      sum+=A[j];
                      dp[i][j]=(double)sum/(double)num;
                  }
                  continue;
              }
              for(int j=0;j<A.length;j++)
              {
                  int num=0;
                  int sum=0;
                  for(int t=j;t>=0;t--)
                  {
                      sum+=A[t];
                      num++;
                      double pre=0;
                      if(i-1>=0 && t-1>=0)
                      {
                           pre=dp[i-1][t-1]; 
                          dp[i][j]=Math.max(dp[i][j],((double)(sum)/(double)(num))+pre); 
                      }   
                  }
              }
          }
          ans=dp[K-1][A.length-1];
          return ans;
      }
  }
  ```

  

- 解题思路

  状态转移方程：
  $$
  dp[i][j]=Math.max(dp[i][j],sum/num) \\
  i为第i个分组，j为当前下标
  $$
  

## 最佳观光组合

- 题目描述

  给定正整数数组 `A`，`A[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的距离为 `j - i`。

  一对景点（`i < j`）组成的观光组合的得分为（`A[i] + A[j] + i - j`）：景点的评分之和**减去**它们两者之间的距离。

  返回一对观光景点能取得的最高分。

- ACCODE

  ```java
  class Solution {
      public int maxScoreSightseeingPair(int[] A) {
          Stack<Integer> stack=new Stack<>();
          int []dp=new int [A.length];
          int ans=Integer.MIN_VALUE;
          for(int i=0;i<A.length;i++)
          {
              if(stack.isEmpty())stack.push(i);
              else
              {
                  while(!stack.isEmpty())
                  {
                      dp[i]=Math.max(dp[i],stack.peek()-i+A[i]+A[stack.peek()]);
                      if(A[stack.peek()]<=A[i])stack.pop();
                      else break;
                  }
                  stack.push(i);
                  ans=Math.max(ans,dp[i]);
              }
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  利用单调栈的思路，我选择的话应该是又大又近最好，单调栈中存的是最近比我大的值。

## 二维区域和检索-矩阵不可变

- 题目描述

  给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (*row*1, *col*1) ，右下角为 (*row*2, *col*2)。

  ![Range Sum Query 2D](https://leetcode-cn.com/static/images/courses/range_sum_query_2d.png)
   上图子矩阵左上角 (row1, col1) = **(2, 1)** ，右下角(row2, col2) = **(4, 3)，**该子矩形内元素的总和为 8。

  **示例:**

  ```
  给定 matrix = [
    [3, 0, 1, 4, 2],
    [5, 6, 3, 2, 1],
    [1, 2, 0, 1, 5],
    [4, 1, 0, 1, 7],
    [1, 0, 3, 0, 5]
  ]
  
  sumRegion(2, 1, 4, 3) -> 8
  sumRegion(1, 1, 2, 2) -> 11
  sumRegion(1, 2, 2, 4) -> 12
  ```

- ACcode

  ```java
  class NumMatrix {
      int[][] dp;
      public NumMatrix(int[][] matrix) {
          if(matrix.length==0)return;
          dp=new int[matrix.length][matrix[0].length];
          for(int i=0;i<matrix.length;i++)
          {
              for(int j=0;j<matrix[0].length;j++)
              {
                  int up=0;
                  int left=0;
                  int leftUp=0;
                  if(i-1>=0)up=dp[i-1][j];
                  if(j-1>=0)left=dp[i][j-1];
                  if(i-1>=0 && j-1>=0)leftUp=dp[i-1][j-1];
                  dp[i][j]=up+left-leftUp+matrix[i][j];
              }
          }
      }
      
      public int sumRegion(int row1, int col1, int row2, int col2) {
          int row1col2=0;
          int row2col1=0;
          int row1col1=0;
          int row2col2=dp[row2][col2];
          if(row1-1>=0)row1col2=dp[row1-1][col2];
          if(col1-1>=0)row2col1=dp[row2][col1-1];
          if(row1-1>=0 && col1-1>=0)row1col1=dp[row1-1][col1-1];
          return row2col2-row1col2-row2col1+row1col1;
      }
  }
  
  /**
   * Your NumMatrix object will be instantiated and called as such:
   * NumMatrix obj = new NumMatrix(matrix);
   * int param_1 = obj.sumRegion(row1,col1,row2,col2);
   */
  ```

  

- 解题思路

  构造矩阵的值：
  $$
  dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+matrix[i][j]
  $$
  计算子矩阵值：
  $$
  dp[row2][col2]-dp[row1-1][col2]-dp[row2][col1-1]+dp[row1-1][col1-1]
  $$



## 单词拆分

- 题目描述

  给定一个**非空**字符串 *s* 和一个包含**非空**单词列表的字典 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

  **说明：**

  - 拆分时可以重复使用字典中的单词。
  - 你可以假设字典中没有重复的单词。

  **示例 1：**

  ```
  输入: s = "leetcode", wordDict = ["leet", "code"]
  输出: true
  解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
  ```

  **示例 2：**

  ```
  输入: s = "applepenapple", wordDict = ["apple", "pen"]
  输出: true
  解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
       注意你可以重复使用字典中的单词。
  ```

  **示例 3：**

  ```
  输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
  输出: false
  ```

- ACcode

  ```java
  class Solution {
      public boolean wordBreak(String s, List<String> wordDict) {
          boolean []vis=new boolean[s.length()+1];
          vis[0]=true;
          for(int i=1;i<=s.length();i++)
          {
              for(int j=i;j>0;j--)
              {
                  String sub=s.substring(i-j,i);
                  if(vis[i-j] && find(wordDict,sub))
                      vis[i]=true;
              }
          }
          return vis[s.length()];
      }
      boolean find(List<String> wordDict,String s)
      {
          for(String tmp:wordDict)
              if(tmp.equals(s))
                  return true;
          return false;
      }
  }
  ```

  

- 解题思路

尝试在字符串s的每个位置按照空格进行划分，如果substring(i-j,i)在列表中出现并且前i-j个字符组成的子串也出现过，则前i个字符也就可以在列表中找到。所以vis[i]=true;





## 乘积小于K的子数组

- 题目描述

  给定一个正整数数组 `nums`。

  找出该数组内乘积小于 `k` 的连续的子数组的个数。

  **示例 1:**

  ```
  输入: nums = [10,5,2,6], k = 100
  输出: 8
  解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
  需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
  ```

  **说明:**

  - `0 < nums.length <= 50000`
  - `0 < nums[i] < 1000`
  - `0 <= k < 10^6`

- ACcode

  ```java
  class Solution {
      public int numSubarrayProductLessThanK(int[] nums, int k) {
          if(nums.length==0)return 0;
          if(k<=1)return 0;
          int left=0;
          int sum=1;
          int ans=0;
          for(int right=0;right<nums.length;right++)
          {
              sum*=nums[right];
              while(sum>=k)
              {
                  sum/=nums[left];
                  left++;
              }
              ans+=right-left+1;
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  这道题我一开始想的也是滑动窗口的算法，但是我想的是有点类似莫队的想法，每次如果小了就往右移一位，大了left就往右移一位，但是我没想到的是如何求中间的数。其实很简单：
  $$
  rigt-left+1
  $$
  1，2，3

  2，3

  3

  AC的代码是每次都往右移，那么每次计算的时候都会是新的子数组。



## 最长的斐波那契子序列的长度

- 题目描述

  如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 *斐波那契式* 的：

  - `n >= 3`
  - 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

  给定一个**严格递增**的正整数数组形成序列，找到 `A` 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

  *（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）*

   

   

  **示例 1：**

  ```
  输入: [1,2,3,4,5,6,7,8]
  输出: 5
  解释:
  最长的斐波那契式子序列为：[1,2,3,5,8] 。
  ```

  **示例 2：**

  ```
  输入: [1,3,7,11,12,14,18]
  输出: 3
  解释:
  最长的斐波那契式子序列有：
  [1,11,12]，[3,11,14] 以及 [7,11,18] 。
  ```

- ACcode

  ```java
  class Solution {
      public int lenLongestFibSubseq(int[] A) {
          if(A.length<3)return 0;
          HashMap<Integer,Integer>local=new HashMap<>();
          HashMap<Integer,HashMap<Integer,Integer>>mp=new HashMap<>();
          for(int i=0;i<A.length;i++)local.put(A[i],i);
          int ans=0;
          for(int i=2;i<A.length;i++)
          {
              HashMap<Integer,Integer> curMatch=new HashMap<>();
              for(int j=i-1;j>=0;j--)
              {
                  int tmp=A[i]-A[j];
                  if(tmp>=A[j])break;
                  HashMap<Integer,Integer> match=mp.get(A[j]);
                  if(match!=null && match.containsKey(tmp))
                  {
                      curMatch.put(A[j],match.get(tmp)+1);
                      ans=Math.max(match.get(tmp)+1,ans);
                  }
                  else
                  {
                      if(local.containsKey(tmp))
                      {
                          curMatch.put(A[j],3);
                          ans=Math.max(ans,3);
                      }
                  }
              }
              mp.put(A[i],curMatch);
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  时间复杂度O（n^2logn）。

  我的思路是先判断是否会在前面的数中找到一组斐波那契子序列，如果找到则将他添加到map中，如果没有则看前面的数中是否出现过，然后标记长度为3.



## 和可被K整除的子数组

- 题目描述

  给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。

   

  **示例：**

  ```
  输入：A = [4,5,0,-2,-3,1], K = 5
  输出：7
  解释：
  有 7 个子数组满足其元素之和可被 K = 5 整除：
  [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
  ```

   

  **提示：**

  1. `1 <= A.length <= 30000`
  2. `-10000 <= A[i] <= 10000`
  3. `2 <= K <= 10000`

- ACcode

  ```java
  class Solution {
      public int subarraysDivByK(int[] A, int K) {
          if(A.length==0)return 0;
         int []sum=new int [A.length];
          sum[0]=A[0];
          for(int i=1;i<A.length;i++)sum[i]+=sum[i-1]+A[i];
          int ans=0;
          HashMap<Integer,Integer> mp=new HashMap<>();
          mp.put(0,1);
          for(int i=0;i<sum.length;i++)
          {
              int p=(sum[i]%K+K)%K;
              Integer tmp=mp.get(p);
              if(tmp==null)tmp=0;
              ans+=tmp;
              tmp++;
              mp.put(p,tmp);
          }
          return ans;
      }
  }
  ```

  

- 解题思路

  这道题的思路我一开始想的是暴力累加计算，但是超时了。这里介绍一下**统计共同余数**的解法。

  对于两个数i和j，如果i%k==j%k，则(i-j)%k==0，所以先用一个数组进行累加计算，对共同余数进行一个累加计算。

  例如：

  0.......1.......1.......1

  --------+++++++++

  ----------------+++++

  .........0.......1.......2

  这里要注意两个问题：

  1. 负数求余数：A[i]%K+K
  2. 余数为0的时候最开始赋1，其余赋0，因为如果余数一开始不是0都无法被K整除，只有余数为0的时候一开始才能被K整除。



## 最小差值2

- 题目描述

  给定一个整数数组 `A`，对于每个整数 `A[i]`，我们可以选择 **x = -K 或是 x = K**，并将 `x` 加到 `A[i]` 中。

  在此过程之后，我们得到一些数组 `B`。

  返回 `B` 的最大值和 `B` 的最小值之间可能存在的最小差值。

   

   

  **示例 1：**

  ```
  输入：A = [1], K = 0
  输出：0
  解释：B = [1]
  ```

  **示例 2：**

  ```
  输入：A = [0,10], K = 2
  输出：6
  解释：B = [2,8]
  ```

  **示例 3：**

  ```
  输入：A = [1,3,6], K = 3
  输出：3
  解释：B = [4,6,3]
  ```

   

  **提示：**

  1. `1 <= A.length <= 10000`
  2. `0 <= A[i] <= 10000`
  3. `0 <= K <= 10000`

- ACcode

  ```java
  class Solution {
      public int smallestRangeII(int[] A, int K) {
           Arrays.sort(A);
          int n = A.length;
          int res = A[n-1] - A[0];
          for (int i=1;i<n;i++) {
            int min = Math.min(A[0]+K,A[i]-K);//有可能A[0]+k都还是最小
            int max = Math.max(A[n-1]-K,A[i-1]+K);//有可能在此出现鸿沟，导致负数出现，所以要和A[N-1]比
            res = Math.min(max-min,res);
          }
          return res;
      }
  }
  ```

  

- 解题思路

  思路是在排好序的一个数组中，找到一个数，使其左边的数都加上K，右边的数都减去K。

  证明：

  假设已经排好序了，对于某一个位置的数如果其左侧的数+K，则只会导致最小值变大，更加利于结果。

  如果其左侧的数-K，则会导致最大值变小，更加利于结果。



## 反转矩阵后的得分

- 题意描述

  有一个二维矩阵 `A` 其中每个元素的值为 `0` 或 `1` 。

  移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 `0` 都更改为 `1`，将所有 `1` 都更改为 `0`。

  在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

  返回尽可能高的分数。

   

   

  **示例：**

  ```
  输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
  输出：39
  解释：
  转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
  0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
  ```

   

  **提示：**

  1. `1 <= A.length <= 20`
  2. `1 <= A[0].length <= 20`
  3. `A[i][j]` 是 `0` 或 `1`

- ACcode

  ```java
  class Solution {
      public int matrixScore(int[][] A) {
          int h=A.length;
          int w=A[0].length;
          for(int i=0;i<h;i++)
          {
              if(A[i][0]!=1)
              {
                  for(int j=0;j<w;j++)
                  {
                      A[i][j]^=1;
                  }
              }
          }
          int sum=0;
          int k=1;
          for(int j=w-1;j>=0;j--)
          {
              int count=0;
              for(int i=0;i<h;i++)
              {
                  if(A[i][j]==1)count++;
              }
              count=Math.max(count,A.length-count);
              sum+=count*k;
              k=k<<1;
              /**
              if(count<=(A.length/2))
              {
                  for(int i=0;i<A.length;i++)
                  {
                      A[i][j]^=1;
                  }
              }
              */
          }
          return sum;
      }
  }
  ```

  

- 解题思路

  思路：先将每行的从左至右的第一个变成1，然后再从第2列开始，判断每一列的1的个数，如果小于一半，则进行反转。加不是一行一行加而是一列一列加。
  java访问数组的长度也会耗时。

## 最长等差序列

- 题目描述

  给定一个整数数组 `A`，返回 `A` 中最长等差子序列的**长度**。

  回想一下，`A` 的子序列是列表 `A[i_1], A[i_2], ..., A[i_k]` 其中 `0 <= i_1 < i_2 < ... < i_k <= A.length - 1`。并且如果 `B[i+1] - B[i]`( `0 <= i < B.length - 1`) 的值都相同，那么序列 `B` 是等差的。

   

  **示例 1：**

  ```
  输入：[3,6,9,12]
  输出：4
  解释： 
  整个数组是公差为 3 的等差数列。
  ```

  **示例 2：**

  ```
  输入：[9,4,7,2,10]
  输出：3
  解释：
  最长的等差子序列是 [4,7,10]。
  ```

  **示例 3：**

  ```
  输入：[20,1,15,3,10,5,8]
  输出：4
  解释：
  最长的等差子序列是 [20,15,10,5]。
  ```

   

  **提示：**

  1. `2 <= A.length <= 2000`
  2. `0 <= A[i] <= 10000`

- ACcode

  ```java
  class Solution {
      public int longestArithSeqLength(int[] A) {
          //ArrayList<HashMap<Integer,Integer>> arrayList=new ArrayList<>();
          int [][]arrayList=new int [A.length][20001];
          int ans=0;
          for(int i=1;i<A.length;i++)
          {
              for(int j=0;j<i;j++)
              {
                  int tmp=A[i]-A[j]+10000;//防止出现负数
                  if(arrayList[j][tmp]==0)arrayList[i][tmp]=1;
                  else arrayList[i][tmp]=arrayList[j][tmp]+1;
                  ans=Math.max(arrayList[i][tmp],ans);
              }
          }
          return ans+1;
      }
  }
  ```

  

- 解题思路

  这道题的思路是一道动态规划的题目，对于f(i,j)，i代表第i个数，j代表差。

  状态转移方程：
  $$
  t=A[i]-A[j];\\
  f(i,t)=f(j,t)+1;
  $$
  



## 下一个排列

- 题目描述

  实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

  如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

  必须**原地**修改，只允许使用额外常数空间。

  以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
   `1,2,3` → `1,3,2`
   `3,2,1` → `1,2,3`
   `1,1,5` → `1,5,1`

- ACcode

  ```java
  class Solution {
      public void nextPermutation(int[] nums) {
          if(nums.length==1 || nums.length==0)return;
          int pointer=nums.length-2;
          while(pointer>=0){
              if(nums[pointer]<nums[pointer+1])
              {
                  break;
              }
              else
              {
                  pointer--;
              }
          }
          if(pointer<0)
          {
              Arrays.sort(nums);
              return ;
          }
          else
          {
              int right=nums.length-1;
              while(right>=pointer)
              {
                  if(nums[right]>nums[pointer])
                  {
                      nums[right]^=nums[pointer];
                      nums[pointer]^=nums[right];
                      nums[right]^=nums[pointer];
                      Arrays.sort(nums,pointer+1,nums.length);
                      break;
                  }
                  else
                  {
                      right--;
                  }
              }
              return ;
          }
      }
  }
  
  //1ms
  /*******
  *这里不使用排序O（nlogn）的算法，因为后面已经是逆序的了，只需要首尾两个指针所指的值进行交换即可得到升序，时间复杂度O（n）。
  */
  class Solution {
      public void nextPermutation(int[] nums) {
          if(nums.length==1 || nums.length==0)return;
          int pointer=nums.length-2;
          while(pointer>=0){
              if(nums[pointer]<nums[pointer+1])
              {
                  break;
              }
              else
              {
                  pointer--;
              }
          }
          if(pointer<0)
          {
              reverse(nums,0);
              return ;
          }
          else
          {
              int right=nums.length-1;
              while(right>=pointer)
              {
                  if(nums[right]>nums[pointer])
                  {
                      nums[right]^=nums[pointer];
                      nums[pointer]^=nums[right];
                      nums[right]^=nums[pointer];
                      reverse(nums,pointer+1);
                      break;
                  }
                  else
                  {
                      right--;
                  }
              }
              return ;
          }
      }
      void reverse(int []nums,int start){
          int i=start,j=nums.length-1;
          while(i<j){
              nums[i]^=nums[j];
              nums[j]^=nums[i];
              nums[i]^=nums[j];
              i++;
              j--;
          }
      }
  }
  ```

  

- 解题思路

  这道题是有点找规律的意思。

  首先如果是一个递减序列，说明已经是最大了，所以不能再进行全排列了。所以只能排序成最小的。

  如果不是递减序列，说明还有全排列。

  如果从i到length-1这一段不是递减序列，说明在这一段有全排列，所以前面的肯定不能动。这时再从后面往前找直到i，找到的第一个大于i的数，进行交换，（为什么这样交换保证下一个是紧挨着的全排列？因为从i+1开始一直到length都是递减的了，从后往前找到的第一个大于i的数肯定是下一个排列中最小的）。交换完后还要对i+1到length进行一次排序（由低到高）。（为什么？例如135421，交换完后145321不是下一个排列最小的，而是再次进行升序排序后141235才是。）

  java中排序指定从begin到end的排序

  Arrays.sort(array,begin,end) //array为数组，begin为开始的位置，end为末尾元素的后一位。